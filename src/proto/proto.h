//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: message.fbe
// FBE version: 1.14.5.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace proto {
using namespace FBE;
} // namespace proto

namespace FBE {
using namespace ::proto;
} // namespace FBE

namespace proto {

enum class MessageType : uint8_t
{
    MSG_TYPE_BASE = (uint8_t)0u,
    MSG_TYPE_LAUNCH = (uint8_t)1u,
    MSG_TYPE_APP,
    MSG_TYPE_LAST = (uint8_t)254u,
    MSG_TYPE_MAX = MSG_TYPE_LAST,
};

std::ostream& operator<<(std::ostream& stream, MessageType value);

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
} template <> struct fmt::formatter<proto::MessageType> : ostream_formatter {}; namespace proto {
#endif

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, MessageType value);
#endif

struct MessageResponse;

struct MessageRequest
{
    typedef MessageResponse Response;

    FBE::uuid_t id;
    uint8_t type;
    std::string Message;

    size_t fbe_type() const noexcept { return 1; }

    MessageRequest();
    MessageRequest(const FBE::uuid_t& arg_id, uint8_t arg_type, const std::string& arg_Message);
    MessageRequest(const MessageRequest& other) = default;
    MessageRequest(MessageRequest&& other) = default;
    ~MessageRequest() = default;

    MessageRequest& operator=(const MessageRequest& other) = default;
    MessageRequest& operator=(MessageRequest&& other) = default;

    bool operator==(const MessageRequest& other) const noexcept;
    bool operator!=(const MessageRequest& other) const noexcept { return !operator==(other); }
    bool operator<(const MessageRequest& other) const noexcept;
    bool operator<=(const MessageRequest& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MessageRequest& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MessageRequest& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MessageRequest& value);

    void swap(MessageRequest& other) noexcept;
    friend void swap(MessageRequest& value1, MessageRequest& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MessageRequest> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MessageRequest>
{
    typedef proto::MessageRequest argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace proto {

struct MessageResponse
{
    FBE::uuid_t id;
    uint32_t Length;
    uint32_t Hash;
    std::string Message;

    size_t fbe_type() const noexcept { return 2; }

    MessageResponse();
    MessageResponse(const FBE::uuid_t& arg_id, uint32_t arg_Length, uint32_t arg_Hash, const std::string& arg_Message);
    MessageResponse(const MessageResponse& other) = default;
    MessageResponse(MessageResponse&& other) = default;
    ~MessageResponse() = default;

    MessageResponse& operator=(const MessageResponse& other) = default;
    MessageResponse& operator=(MessageResponse&& other) = default;

    bool operator==(const MessageResponse& other) const noexcept;
    bool operator!=(const MessageResponse& other) const noexcept { return !operator==(other); }
    bool operator<(const MessageResponse& other) const noexcept;
    bool operator<=(const MessageResponse& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MessageResponse& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MessageResponse& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MessageResponse& value);

    void swap(MessageResponse& other) noexcept;
    friend void swap(MessageResponse& value1, MessageResponse& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MessageResponse> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MessageResponse>
{
    typedef proto::MessageResponse argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace proto {

struct MessageReject
{
    FBE::uuid_t id;
    std::string Error;

    size_t fbe_type() const noexcept { return 3; }

    MessageReject();
    MessageReject(const FBE::uuid_t& arg_id, const std::string& arg_Error);
    MessageReject(const MessageReject& other) = default;
    MessageReject(MessageReject&& other) = default;
    ~MessageReject() = default;

    MessageReject& operator=(const MessageReject& other) = default;
    MessageReject& operator=(MessageReject&& other) = default;

    bool operator==(const MessageReject& other) const noexcept;
    bool operator!=(const MessageReject& other) const noexcept { return !operator==(other); }
    bool operator<(const MessageReject& other) const noexcept;
    bool operator<=(const MessageReject& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MessageReject& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MessageReject& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MessageReject& value);

    void swap(MessageReject& other) noexcept;
    friend void swap(MessageReject& value1, MessageReject& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MessageReject> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MessageReject>
{
    typedef proto::MessageReject argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace proto {

struct MessageNotify
{
    std::string Notification;

    size_t fbe_type() const noexcept { return 4; }

    MessageNotify();
    explicit MessageNotify(const std::string& arg_Notification);
    MessageNotify(const MessageNotify& other) = default;
    MessageNotify(MessageNotify&& other) = default;
    ~MessageNotify() = default;

    MessageNotify& operator=(const MessageNotify& other) = default;
    MessageNotify& operator=(MessageNotify&& other) = default;

    bool operator==(const MessageNotify& other) const noexcept;
    bool operator!=(const MessageNotify& other) const noexcept { return !operator==(other); }
    bool operator<(const MessageNotify& other) const noexcept;
    bool operator<=(const MessageNotify& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MessageNotify& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MessageNotify& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MessageNotify& value);

    void swap(MessageNotify& other) noexcept;
    friend void swap(MessageNotify& value1, MessageNotify& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MessageNotify> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MessageNotify>
{
    typedef proto::MessageNotify argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct DisconnectRequest
{
    FBE::uuid_t id;

    size_t fbe_type() const noexcept { return 5; }

    DisconnectRequest();
    explicit DisconnectRequest(const FBE::uuid_t& arg_id);
    DisconnectRequest(const DisconnectRequest& other) = default;
    DisconnectRequest(DisconnectRequest&& other) = default;
    ~DisconnectRequest() = default;

    DisconnectRequest& operator=(const DisconnectRequest& other) = default;
    DisconnectRequest& operator=(DisconnectRequest&& other) = default;

    bool operator==(const DisconnectRequest& other) const noexcept;
    bool operator!=(const DisconnectRequest& other) const noexcept { return !operator==(other); }
    bool operator<(const DisconnectRequest& other) const noexcept;
    bool operator<=(const DisconnectRequest& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DisconnectRequest& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DisconnectRequest& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const DisconnectRequest& value);

    void swap(DisconnectRequest& other) noexcept;
    friend void swap(DisconnectRequest& value1, DisconnectRequest& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::DisconnectRequest> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::DisconnectRequest>
{
    typedef proto::DisconnectRequest argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace proto {

} // namespace proto
