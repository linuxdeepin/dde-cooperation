//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: message.fbe
// FBE version: 1.14.5.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace proto {
using namespace FBE;
} // namespace proto

namespace FBE {
using namespace ::proto;
} // namespace FBE

namespace proto {

struct OriginMessage;

struct OriginMessage
{
    typedef OriginMessage Response;

    FBE::uuid_t id;
    int32_t mask;
    std::string json_msg;

    size_t fbe_type() const noexcept { return 1; }

    OriginMessage();
    OriginMessage(const FBE::uuid_t& arg_id, int32_t arg_mask, const std::string& arg_json_msg);
    OriginMessage(const OriginMessage& other) = default;
    OriginMessage(OriginMessage&& other) = default;
    ~OriginMessage() = default;

    OriginMessage& operator=(const OriginMessage& other) = default;
    OriginMessage& operator=(OriginMessage&& other) = default;

    bool operator==(const OriginMessage& other) const noexcept;
    bool operator!=(const OriginMessage& other) const noexcept { return !operator==(other); }
    bool operator<(const OriginMessage& other) const noexcept;
    bool operator<=(const OriginMessage& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const OriginMessage& other) const noexcept { return !operator<=(other); }
    bool operator>=(const OriginMessage& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const OriginMessage& value);

    void swap(OriginMessage& other) noexcept;
    friend void swap(OriginMessage& value1, OriginMessage& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::OriginMessage> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::OriginMessage>
{
    typedef proto::OriginMessage argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace proto {

struct MessageReject
{
    FBE::uuid_t id;
    std::string error;

    size_t fbe_type() const noexcept { return 2; }

    MessageReject();
    MessageReject(const FBE::uuid_t& arg_id, const std::string& arg_error);
    MessageReject(const MessageReject& other) = default;
    MessageReject(MessageReject&& other) = default;
    ~MessageReject() = default;

    MessageReject& operator=(const MessageReject& other) = default;
    MessageReject& operator=(MessageReject&& other) = default;

    bool operator==(const MessageReject& other) const noexcept;
    bool operator!=(const MessageReject& other) const noexcept { return !operator==(other); }
    bool operator<(const MessageReject& other) const noexcept;
    bool operator<=(const MessageReject& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MessageReject& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MessageReject& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MessageReject& value);

    void swap(MessageReject& other) noexcept;
    friend void swap(MessageReject& value1, MessageReject& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MessageReject> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MessageReject>
{
    typedef proto::MessageReject argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace proto {

struct MessageNotify
{
    std::string notification;

    size_t fbe_type() const noexcept { return 3; }

    MessageNotify();
    explicit MessageNotify(const std::string& arg_notification);
    MessageNotify(const MessageNotify& other) = default;
    MessageNotify(MessageNotify&& other) = default;
    ~MessageNotify() = default;

    MessageNotify& operator=(const MessageNotify& other) = default;
    MessageNotify& operator=(MessageNotify&& other) = default;

    bool operator==(const MessageNotify& other) const noexcept;
    bool operator!=(const MessageNotify& other) const noexcept { return !operator==(other); }
    bool operator<(const MessageNotify& other) const noexcept;
    bool operator<=(const MessageNotify& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MessageNotify& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MessageNotify& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MessageNotify& value);

    void swap(MessageNotify& other) noexcept;
    friend void swap(MessageNotify& value1, MessageNotify& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MessageNotify> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MessageNotify>
{
    typedef proto::MessageNotify argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct DisconnectRequest
{
    FBE::uuid_t id;

    size_t fbe_type() const noexcept { return 4; }

    DisconnectRequest();
    explicit DisconnectRequest(const FBE::uuid_t& arg_id);
    DisconnectRequest(const DisconnectRequest& other) = default;
    DisconnectRequest(DisconnectRequest&& other) = default;
    ~DisconnectRequest() = default;

    DisconnectRequest& operator=(const DisconnectRequest& other) = default;
    DisconnectRequest& operator=(DisconnectRequest&& other) = default;

    bool operator==(const DisconnectRequest& other) const noexcept;
    bool operator!=(const DisconnectRequest& other) const noexcept { return !operator==(other); }
    bool operator<(const DisconnectRequest& other) const noexcept;
    bool operator<=(const DisconnectRequest& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DisconnectRequest& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DisconnectRequest& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const DisconnectRequest& value);

    void swap(DisconnectRequest& other) noexcept;
    friend void swap(DisconnectRequest& value1, DisconnectRequest& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::DisconnectRequest> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::DisconnectRequest>
{
    typedef proto::DisconnectRequest argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace proto {

} // namespace proto
