//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: message.fbe
// FBE version: 1.14.5.0
//------------------------------------------------------------------------------

#include "proto.h"

namespace proto {

std::ostream& operator<<(std::ostream& stream, MessageType value)
{
    if (value == MessageType::MSG_TYPE_BASE) return stream << "MSG_TYPE_BASE";
    if (value == MessageType::MSG_TYPE_LAUNCH) return stream << "MSG_TYPE_LAUNCH";
    if (value == MessageType::MSG_TYPE_APP) return stream << "MSG_TYPE_APP";
    if (value == MessageType::MSG_TYPE_LAST) return stream << "MSG_TYPE_LAST";
    if (value == MessageType::MSG_TYPE_MAX) return stream << "MSG_TYPE_MAX";
    return stream << "<unknown>";
}

MessageRequest::MessageRequest()
    : id(FBE::uuid_t::sequential())
    , type((uint8_t)0u)
    , Message()
{}

MessageRequest::MessageRequest(const FBE::uuid_t& arg_id, uint8_t arg_type, const std::string& arg_Message)
    : id(arg_id)
    , type(arg_type)
    , Message(arg_Message)
{}

bool MessageRequest::operator==(const MessageRequest& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool MessageRequest::operator<(const MessageRequest& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void MessageRequest::swap(MessageRequest& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(type, other.type);
    swap(Message, other.Message);
}

std::ostream& operator<<(std::ostream& stream, const MessageRequest& value)
{
    stream << "MessageRequest(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ",type="; stream << (int)value.type;
    stream << ",Message="; stream << "\"" << value.Message << "\"";
    stream << ")";
    return stream;
}

MessageResponse::MessageResponse()
    : id(FBE::uuid_t::sequential())
    , Length((uint32_t)0ull)
    , Hash((uint32_t)0ull)
    , Message()
{}

MessageResponse::MessageResponse(const FBE::uuid_t& arg_id, uint32_t arg_Length, uint32_t arg_Hash, const std::string& arg_Message)
    : id(arg_id)
    , Length(arg_Length)
    , Hash(arg_Hash)
    , Message(arg_Message)
{}

bool MessageResponse::operator==(const MessageResponse& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool MessageResponse::operator<(const MessageResponse& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void MessageResponse::swap(MessageResponse& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(Length, other.Length);
    swap(Hash, other.Hash);
    swap(Message, other.Message);
}

std::ostream& operator<<(std::ostream& stream, const MessageResponse& value)
{
    stream << "MessageResponse(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ",Length="; stream << value.Length;
    stream << ",Hash="; stream << value.Hash;
    stream << ",Message="; stream << "\"" << value.Message << "\"";
    stream << ")";
    return stream;
}

MessageReject::MessageReject()
    : id(FBE::uuid_t::sequential())
    , Error()
{}

MessageReject::MessageReject(const FBE::uuid_t& arg_id, const std::string& arg_Error)
    : id(arg_id)
    , Error(arg_Error)
{}

bool MessageReject::operator==(const MessageReject& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool MessageReject::operator<(const MessageReject& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void MessageReject::swap(MessageReject& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(Error, other.Error);
}

std::ostream& operator<<(std::ostream& stream, const MessageReject& value)
{
    stream << "MessageReject(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ",Error="; stream << "\"" << value.Error << "\"";
    stream << ")";
    return stream;
}

MessageNotify::MessageNotify()
    : Notification()
{}

MessageNotify::MessageNotify(const std::string& arg_Notification)
    : Notification(arg_Notification)
{}

bool MessageNotify::operator==(const MessageNotify& other) const noexcept
{
    return (
        true
        );
}

bool MessageNotify::operator<(const MessageNotify& other) const noexcept
{
    return false;
}

void MessageNotify::swap(MessageNotify& other) noexcept
{
    using std::swap;
    swap(Notification, other.Notification);
}

std::ostream& operator<<(std::ostream& stream, const MessageNotify& value)
{
    stream << "MessageNotify(";
    stream << "Notification="; stream << "\"" << value.Notification << "\"";
    stream << ")";
    return stream;
}

DisconnectRequest::DisconnectRequest()
    : id(FBE::uuid_t::sequential())
{}

DisconnectRequest::DisconnectRequest(const FBE::uuid_t& arg_id)
    : id(arg_id)
{}

bool DisconnectRequest::operator==(const DisconnectRequest& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool DisconnectRequest::operator<(const DisconnectRequest& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void DisconnectRequest::swap(DisconnectRequest& other) noexcept
{
    using std::swap;
    swap(id, other.id);
}

std::ostream& operator<<(std::ostream& stream, const DisconnectRequest& value)
{
    stream << "DisconnectRequest(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ")";
    return stream;
}

} // namespace proto
