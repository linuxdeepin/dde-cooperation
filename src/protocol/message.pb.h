// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_INCLUDED_message_2eproto
#define PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_message_2eproto();
class ChatMessage;
class ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class FileAction;
class FileActionDefaultTypeInternal;
extern FileActionDefaultTypeInternal _FileAction_default_instance_;
class FileCreate;
class FileCreateDefaultTypeInternal;
extern FileCreateDefaultTypeInternal _FileCreate_default_instance_;
class FileDirectory;
class FileDirectoryDefaultTypeInternal;
extern FileDirectoryDefaultTypeInternal _FileDirectory_default_instance_;
class FileEntry;
class FileEntryDefaultTypeInternal;
extern FileEntryDefaultTypeInternal _FileEntry_default_instance_;
class FileRemove;
class FileRemoveDefaultTypeInternal;
extern FileRemoveDefaultTypeInternal _FileRemove_default_instance_;
class FileRename;
class FileRenameDefaultTypeInternal;
extern FileRenameDefaultTypeInternal _FileRename_default_instance_;
class FileResponse;
class FileResponseDefaultTypeInternal;
extern FileResponseDefaultTypeInternal _FileResponse_default_instance_;
class FileTransBlock;
class FileTransBlockDefaultTypeInternal;
extern FileTransBlockDefaultTypeInternal _FileTransBlock_default_instance_;
class FileTransCreate;
class FileTransCreateDefaultTypeInternal;
extern FileTransCreateDefaultTypeInternal _FileTransCreate_default_instance_;
class FileTransJob;
class FileTransJobDefaultTypeInternal;
extern FileTransJobDefaultTypeInternal _FileTransJob_default_instance_;
class FileTransJobCancel;
class FileTransJobCancelDefaultTypeInternal;
extern FileTransJobCancelDefaultTypeInternal _FileTransJobCancel_default_instance_;
class FileTransJobReport;
class FileTransJobReportDefaultTypeInternal;
extern FileTransJobReportDefaultTypeInternal _FileTransJobReport_default_instance_;
class FileTransResponse;
class FileTransResponseDefaultTypeInternal;
extern FileTransResponseDefaultTypeInternal _FileTransResponse_default_instance_;
class FileTransUpdate;
class FileTransUpdateDefaultTypeInternal;
extern FileTransUpdateDefaultTypeInternal _FileTransUpdate_default_instance_;
class FileTransferBlock;
class FileTransferBlockDefaultTypeInternal;
extern FileTransferBlockDefaultTypeInternal _FileTransferBlock_default_instance_;
class FileTransferCancel;
class FileTransferCancelDefaultTypeInternal;
extern FileTransferCancelDefaultTypeInternal _FileTransferCancel_default_instance_;
class FileTransferConfirm;
class FileTransferConfirmDefaultTypeInternal;
extern FileTransferConfirmDefaultTypeInternal _FileTransferConfirm_default_instance_;
class FileTransferDigest;
class FileTransferDigestDefaultTypeInternal;
extern FileTransferDigestDefaultTypeInternal _FileTransferDigest_default_instance_;
class FileTransferDone;
class FileTransferDoneDefaultTypeInternal;
extern FileTransferDoneDefaultTypeInternal _FileTransferDone_default_instance_;
class FileTransferError;
class FileTransferErrorDefaultTypeInternal;
extern FileTransferErrorDefaultTypeInternal _FileTransferError_default_instance_;
class FileTransferRequest;
class FileTransferRequestDefaultTypeInternal;
extern FileTransferRequestDefaultTypeInternal _FileTransferRequest_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class Misc;
class MiscDefaultTypeInternal;
extern MiscDefaultTypeInternal _Misc_default_instance_;
class OptionMessage;
class OptionMessageDefaultTypeInternal;
extern OptionMessageDefaultTypeInternal _OptionMessage_default_instance_;
class PeerInfo;
class PeerInfoDefaultTypeInternal;
extern PeerInfoDefaultTypeInternal _PeerInfo_default_instance_;
class PermissionInfo;
class PermissionInfoDefaultTypeInternal;
extern PermissionInfoDefaultTypeInternal _PermissionInfo_default_instance_;
class ReadDirFiles;
class ReadDirFilesDefaultTypeInternal;
extern ReadDirFilesDefaultTypeInternal _ReadDirFiles_default_instance_;
namespace google {
namespace protobuf {
template<> ::ChatMessage* Arena::CreateMaybeMessage<::ChatMessage>(Arena*);
template<> ::FileAction* Arena::CreateMaybeMessage<::FileAction>(Arena*);
template<> ::FileCreate* Arena::CreateMaybeMessage<::FileCreate>(Arena*);
template<> ::FileDirectory* Arena::CreateMaybeMessage<::FileDirectory>(Arena*);
template<> ::FileEntry* Arena::CreateMaybeMessage<::FileEntry>(Arena*);
template<> ::FileRemove* Arena::CreateMaybeMessage<::FileRemove>(Arena*);
template<> ::FileRename* Arena::CreateMaybeMessage<::FileRename>(Arena*);
template<> ::FileResponse* Arena::CreateMaybeMessage<::FileResponse>(Arena*);
template<> ::FileTransBlock* Arena::CreateMaybeMessage<::FileTransBlock>(Arena*);
template<> ::FileTransCreate* Arena::CreateMaybeMessage<::FileTransCreate>(Arena*);
template<> ::FileTransJob* Arena::CreateMaybeMessage<::FileTransJob>(Arena*);
template<> ::FileTransJobCancel* Arena::CreateMaybeMessage<::FileTransJobCancel>(Arena*);
template<> ::FileTransJobReport* Arena::CreateMaybeMessage<::FileTransJobReport>(Arena*);
template<> ::FileTransResponse* Arena::CreateMaybeMessage<::FileTransResponse>(Arena*);
template<> ::FileTransUpdate* Arena::CreateMaybeMessage<::FileTransUpdate>(Arena*);
template<> ::FileTransferBlock* Arena::CreateMaybeMessage<::FileTransferBlock>(Arena*);
template<> ::FileTransferCancel* Arena::CreateMaybeMessage<::FileTransferCancel>(Arena*);
template<> ::FileTransferConfirm* Arena::CreateMaybeMessage<::FileTransferConfirm>(Arena*);
template<> ::FileTransferDigest* Arena::CreateMaybeMessage<::FileTransferDigest>(Arena*);
template<> ::FileTransferDone* Arena::CreateMaybeMessage<::FileTransferDone>(Arena*);
template<> ::FileTransferError* Arena::CreateMaybeMessage<::FileTransferError>(Arena*);
template<> ::FileTransferRequest* Arena::CreateMaybeMessage<::FileTransferRequest>(Arena*);
template<> ::LoginRequest* Arena::CreateMaybeMessage<::LoginRequest>(Arena*);
template<> ::LoginResponse* Arena::CreateMaybeMessage<::LoginResponse>(Arena*);
template<> ::Misc* Arena::CreateMaybeMessage<::Misc>(Arena*);
template<> ::OptionMessage* Arena::CreateMaybeMessage<::OptionMessage>(Arena*);
template<> ::PeerInfo* Arena::CreateMaybeMessage<::PeerInfo>(Arena*);
template<> ::PermissionInfo* Arena::CreateMaybeMessage<::PermissionInfo>(Arena*);
template<> ::ReadDirFiles* Arena::CreateMaybeMessage<::ReadDirFiles>(Arena*);
}  // namespace protobuf
}  // namespace google

enum PermissionInfo_Permission {
  PermissionInfo_Permission_Keyboard = 0,
  PermissionInfo_Permission_Clipboard = 1,
  PermissionInfo_Permission_File = 2,
  PermissionInfo_Permission_PermissionInfo_Permission_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  PermissionInfo_Permission_PermissionInfo_Permission_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool PermissionInfo_Permission_IsValid(int value);
const PermissionInfo_Permission PermissionInfo_Permission_Permission_MIN = PermissionInfo_Permission_Keyboard;
const PermissionInfo_Permission PermissionInfo_Permission_Permission_MAX = PermissionInfo_Permission_File;
const int PermissionInfo_Permission_Permission_ARRAYSIZE = PermissionInfo_Permission_Permission_MAX + 1;

const ::google::protobuf::EnumDescriptor* PermissionInfo_Permission_descriptor();
inline const ::std::string& PermissionInfo_Permission_Name(PermissionInfo_Permission value) {
  return ::google::protobuf::internal::NameOfEnum(
    PermissionInfo_Permission_descriptor(), value);
}
inline bool PermissionInfo_Permission_Parse(
    const ::std::string& name, PermissionInfo_Permission* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PermissionInfo_Permission>(
    PermissionInfo_Permission_descriptor(), name, value);
}
enum OptionMessage_BoolOption {
  OptionMessage_BoolOption_NotSet = 0,
  OptionMessage_BoolOption_No = 1,
  OptionMessage_BoolOption_Yes = 2,
  OptionMessage_BoolOption_OptionMessage_BoolOption_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  OptionMessage_BoolOption_OptionMessage_BoolOption_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool OptionMessage_BoolOption_IsValid(int value);
const OptionMessage_BoolOption OptionMessage_BoolOption_BoolOption_MIN = OptionMessage_BoolOption_NotSet;
const OptionMessage_BoolOption OptionMessage_BoolOption_BoolOption_MAX = OptionMessage_BoolOption_Yes;
const int OptionMessage_BoolOption_BoolOption_ARRAYSIZE = OptionMessage_BoolOption_BoolOption_MAX + 1;

const ::google::protobuf::EnumDescriptor* OptionMessage_BoolOption_descriptor();
inline const ::std::string& OptionMessage_BoolOption_Name(OptionMessage_BoolOption value) {
  return ::google::protobuf::internal::NameOfEnum(
    OptionMessage_BoolOption_descriptor(), value);
}
inline bool OptionMessage_BoolOption_Parse(
    const ::std::string& name, OptionMessage_BoolOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OptionMessage_BoolOption>(
    OptionMessage_BoolOption_descriptor(), name, value);
}
enum FileTransferRequest_Direction {
  FileTransferRequest_Direction_NotSet = 0,
  FileTransferRequest_Direction_Send = 1,
  FileTransferRequest_Direction_Receive = 2,
  FileTransferRequest_Direction_FileTransferRequest_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  FileTransferRequest_Direction_FileTransferRequest_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool FileTransferRequest_Direction_IsValid(int value);
const FileTransferRequest_Direction FileTransferRequest_Direction_Direction_MIN = FileTransferRequest_Direction_NotSet;
const FileTransferRequest_Direction FileTransferRequest_Direction_Direction_MAX = FileTransferRequest_Direction_Receive;
const int FileTransferRequest_Direction_Direction_ARRAYSIZE = FileTransferRequest_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileTransferRequest_Direction_descriptor();
inline const ::std::string& FileTransferRequest_Direction_Name(FileTransferRequest_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileTransferRequest_Direction_descriptor(), value);
}
inline bool FileTransferRequest_Direction_Parse(
    const ::std::string& name, FileTransferRequest_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileTransferRequest_Direction>(
    FileTransferRequest_Direction_descriptor(), name, value);
}
enum FileType {
  DIR = 0,
  DIR_LINK = 1,
  FILE_B = 2,
  FILE_LINK = 3,
  FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool FileType_IsValid(int value);
const FileType FileType_MIN = DIR;
const FileType FileType_MAX = FILE_LINK;
const int FileType_ARRAYSIZE = FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileType_descriptor();
inline const ::std::string& FileType_Name(FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileType_descriptor(), value);
}
inline bool FileType_Parse(
    const ::std::string& name, FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileType>(
    FileType_descriptor(), name, value);
}
enum FileTransRe {
  IO_ERROR = 0,
  OK = 1,
  FINIASH = 2,
  FileTransRe_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  FileTransRe_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool FileTransRe_IsValid(int value);
const FileTransRe FileTransRe_MIN = IO_ERROR;
const FileTransRe FileTransRe_MAX = FINIASH;
const int FileTransRe_ARRAYSIZE = FileTransRe_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileTransRe_descriptor();
inline const ::std::string& FileTransRe_Name(FileTransRe value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileTransRe_descriptor(), value);
}
inline bool FileTransRe_Parse(
    const ::std::string& name, FileTransRe* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileTransRe>(
    FileTransRe_descriptor(), name, value);
}
// ===================================================================

class LoginRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(nullptr);
  }

  LoginRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes auth = 2;
  void clear_auth();
  static const int kAuthFieldNumber = 2;
  const ::std::string& auth() const;
  void set_auth(const ::std::string& value);
  #if LANG_CXX11
  void set_auth(::std::string&& value);
  #endif
  void set_auth(const char* value);
  void set_auth(const void* value, size_t size);
  ::std::string* mutable_auth();
  ::std::string* release_auth();
  void set_allocated_auth(::std::string* auth);

  // string my_uid = 4;
  void clear_my_uid();
  static const int kMyUidFieldNumber = 4;
  const ::std::string& my_uid() const;
  void set_my_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_my_uid(::std::string&& value);
  #endif
  void set_my_uid(const char* value);
  void set_my_uid(const char* value, size_t size);
  ::std::string* mutable_my_uid();
  ::std::string* release_my_uid();
  void set_allocated_my_uid(::std::string* my_uid);

  // string my_name = 5;
  void clear_my_name();
  static const int kMyNameFieldNumber = 5;
  const ::std::string& my_name() const;
  void set_my_name(const ::std::string& value);
  #if LANG_CXX11
  void set_my_name(::std::string&& value);
  #endif
  void set_my_name(const char* value);
  void set_my_name(const char* value, size_t size);
  ::std::string* mutable_my_name();
  ::std::string* release_my_name();
  void set_allocated_my_name(::std::string* my_name);

  // string version = 8;
  void clear_version();
  static const int kVersionFieldNumber = 8;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .OptionMessage option = 6;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 6;
  const ::OptionMessage& option() const;
  ::OptionMessage* release_option();
  ::OptionMessage* mutable_option();
  void set_allocated_option(::OptionMessage* option);

  // int32 session_id = 7;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 7;
  ::google::protobuf::int32 session_id() const;
  void set_session_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr auth_;
  ::google::protobuf::internal::ArenaStringPtr my_uid_;
  ::google::protobuf::internal::ArenaStringPtr my_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::OptionMessage* option_;
  ::google::protobuf::int32 session_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LoginResponse& default_instance();

  enum UnionCase {
    kError = 1,
    kPeerInfo = 2,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LoginResponse* other);
  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const final {
    return CreateMaybeMessage<LoginResponse>(nullptr);
  }

  LoginResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes token = 3;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // string error = 1;
  private:
  bool has_error() const;
  public:
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .PeerInfo peer_info = 2;
  bool has_peer_info() const;
  void clear_peer_info();
  static const int kPeerInfoFieldNumber = 2;
  const ::PeerInfo& peer_info() const;
  ::PeerInfo* release_peer_info();
  ::PeerInfo* mutable_peer_info();
  void set_allocated_peer_info(::PeerInfo* peer_info);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:LoginResponse)
 private:
  class HasBitSetters;
  void set_has_error();
  void set_has_peer_info();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  union UnionUnion {
    UnionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::PeerInfo* peer_info_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChatMessage) */ {
 public:
  ChatMessage();
  virtual ~ChatMessage();

  ChatMessage(const ChatMessage& from);

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChatMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ChatMessage* other);
  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChatMessage* New() const final {
    return CreateMaybeMessage<ChatMessage>(nullptr);
  }

  ChatMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:ChatMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PeerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PeerInfo) */ {
 public:
  PeerInfo();
  virtual ~PeerInfo();

  PeerInfo(const PeerInfo& from);

  inline PeerInfo& operator=(const PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerInfo(PeerInfo&& from) noexcept
    : PeerInfo() {
    *this = ::std::move(from);
  }

  inline PeerInfo& operator=(PeerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PeerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerInfo* internal_default_instance() {
    return reinterpret_cast<const PeerInfo*>(
               &_PeerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PeerInfo* other);
  friend void swap(PeerInfo& a, PeerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerInfo* New() const final {
    return CreateMaybeMessage<PeerInfo>(nullptr);
  }

  PeerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PeerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PeerInfo& from);
  void MergeFrom(const PeerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string hostname = 2;
  void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // string platform = 3;
  void clear_platform();
  static const int kPlatformFieldNumber = 3;
  const ::std::string& platform() const;
  void set_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_platform(::std::string&& value);
  #endif
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  ::std::string* mutable_platform();
  ::std::string* release_platform();
  void set_allocated_platform(::std::string* platform);

  // string version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // bool privacy_mode = 5;
  void clear_privacy_mode();
  static const int kPrivacyModeFieldNumber = 5;
  bool privacy_mode() const;
  void set_privacy_mode(bool value);

  // @@protoc_insertion_point(class_scope:PeerInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr platform_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  bool privacy_mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PermissionInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PermissionInfo) */ {
 public:
  PermissionInfo();
  virtual ~PermissionInfo();

  PermissionInfo(const PermissionInfo& from);

  inline PermissionInfo& operator=(const PermissionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PermissionInfo(PermissionInfo&& from) noexcept
    : PermissionInfo() {
    *this = ::std::move(from);
  }

  inline PermissionInfo& operator=(PermissionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PermissionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PermissionInfo* internal_default_instance() {
    return reinterpret_cast<const PermissionInfo*>(
               &_PermissionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PermissionInfo* other);
  friend void swap(PermissionInfo& a, PermissionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PermissionInfo* New() const final {
    return CreateMaybeMessage<PermissionInfo>(nullptr);
  }

  PermissionInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PermissionInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PermissionInfo& from);
  void MergeFrom(const PermissionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PermissionInfo_Permission Permission;
  static const Permission Keyboard =
    PermissionInfo_Permission_Keyboard;
  static const Permission Clipboard =
    PermissionInfo_Permission_Clipboard;
  static const Permission File =
    PermissionInfo_Permission_File;
  static inline bool Permission_IsValid(int value) {
    return PermissionInfo_Permission_IsValid(value);
  }
  static const Permission Permission_MIN =
    PermissionInfo_Permission_Permission_MIN;
  static const Permission Permission_MAX =
    PermissionInfo_Permission_Permission_MAX;
  static const int Permission_ARRAYSIZE =
    PermissionInfo_Permission_Permission_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Permission_descriptor() {
    return PermissionInfo_Permission_descriptor();
  }
  static inline const ::std::string& Permission_Name(Permission value) {
    return PermissionInfo_Permission_Name(value);
  }
  static inline bool Permission_Parse(const ::std::string& name,
      Permission* value) {
    return PermissionInfo_Permission_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .PermissionInfo.Permission permission = 1;
  void clear_permission();
  static const int kPermissionFieldNumber = 1;
  ::PermissionInfo_Permission permission() const;
  void set_permission(::PermissionInfo_Permission value);

  // bool enabled = 2;
  void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:PermissionInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int permission_;
  bool enabled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class OptionMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptionMessage) */ {
 public:
  OptionMessage();
  virtual ~OptionMessage();

  OptionMessage(const OptionMessage& from);

  inline OptionMessage& operator=(const OptionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OptionMessage(OptionMessage&& from) noexcept
    : OptionMessage() {
    *this = ::std::move(from);
  }

  inline OptionMessage& operator=(OptionMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OptionMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OptionMessage* internal_default_instance() {
    return reinterpret_cast<const OptionMessage*>(
               &_OptionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OptionMessage* other);
  friend void swap(OptionMessage& a, OptionMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OptionMessage* New() const final {
    return CreateMaybeMessage<OptionMessage>(nullptr);
  }

  OptionMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OptionMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OptionMessage& from);
  void MergeFrom(const OptionMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OptionMessage_BoolOption BoolOption;
  static const BoolOption NotSet =
    OptionMessage_BoolOption_NotSet;
  static const BoolOption No =
    OptionMessage_BoolOption_No;
  static const BoolOption Yes =
    OptionMessage_BoolOption_Yes;
  static inline bool BoolOption_IsValid(int value) {
    return OptionMessage_BoolOption_IsValid(value);
  }
  static const BoolOption BoolOption_MIN =
    OptionMessage_BoolOption_BoolOption_MIN;
  static const BoolOption BoolOption_MAX =
    OptionMessage_BoolOption_BoolOption_MAX;
  static const int BoolOption_ARRAYSIZE =
    OptionMessage_BoolOption_BoolOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BoolOption_descriptor() {
    return OptionMessage_BoolOption_descriptor();
  }
  static inline const ::std::string& BoolOption_Name(BoolOption value) {
    return OptionMessage_BoolOption_Name(value);
  }
  static inline bool BoolOption_Parse(const ::std::string& name,
      BoolOption* value) {
    return OptionMessage_BoolOption_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .OptionMessage.BoolOption lock_after_session_end = 2;
  void clear_lock_after_session_end();
  static const int kLockAfterSessionEndFieldNumber = 2;
  ::OptionMessage_BoolOption lock_after_session_end() const;
  void set_lock_after_session_end(::OptionMessage_BoolOption value);

  // .OptionMessage.BoolOption show_remote_cursor = 3;
  void clear_show_remote_cursor();
  static const int kShowRemoteCursorFieldNumber = 3;
  ::OptionMessage_BoolOption show_remote_cursor() const;
  void set_show_remote_cursor(::OptionMessage_BoolOption value);

  // .OptionMessage.BoolOption privacy_mode = 4;
  void clear_privacy_mode();
  static const int kPrivacyModeFieldNumber = 4;
  ::OptionMessage_BoolOption privacy_mode() const;
  void set_privacy_mode(::OptionMessage_BoolOption value);

  // .OptionMessage.BoolOption block_input = 5;
  void clear_block_input();
  static const int kBlockInputFieldNumber = 5;
  ::OptionMessage_BoolOption block_input() const;
  void set_block_input(::OptionMessage_BoolOption value);

  // .OptionMessage.BoolOption disable_clipboard = 6;
  void clear_disable_clipboard();
  static const int kDisableClipboardFieldNumber = 6;
  ::OptionMessage_BoolOption disable_clipboard() const;
  void set_disable_clipboard(::OptionMessage_BoolOption value);

  // .OptionMessage.BoolOption enable_file_transfer = 7;
  void clear_enable_file_transfer();
  static const int kEnableFileTransferFieldNumber = 7;
  ::OptionMessage_BoolOption enable_file_transfer() const;
  void set_enable_file_transfer(::OptionMessage_BoolOption value);

  // .OptionMessage.BoolOption disable_keyboard = 8;
  void clear_disable_keyboard();
  static const int kDisableKeyboardFieldNumber = 8;
  ::OptionMessage_BoolOption disable_keyboard() const;
  void set_disable_keyboard(::OptionMessage_BoolOption value);

  // @@protoc_insertion_point(class_scope:OptionMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int lock_after_session_end_;
  int show_remote_cursor_;
  int privacy_mode_;
  int block_input_;
  int disable_clipboard_;
  int enable_file_transfer_;
  int disable_keyboard_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileEntry) */ {
 public:
  FileEntry();
  virtual ~FileEntry();

  FileEntry(const FileEntry& from);

  inline FileEntry& operator=(const FileEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileEntry(FileEntry&& from) noexcept
    : FileEntry() {
    *this = ::std::move(from);
  }

  inline FileEntry& operator=(FileEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileEntry* internal_default_instance() {
    return reinterpret_cast<const FileEntry*>(
               &_FileEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FileEntry* other);
  friend void swap(FileEntry& a, FileEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileEntry* New() const final {
    return CreateMaybeMessage<FileEntry>(nullptr);
  }

  FileEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileEntry& from);
  void MergeFrom(const FileEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .FileType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::FileType type() const;
  void set_type(::FileType value);

  // bool hidden = 3;
  void clear_hidden();
  static const int kHiddenFieldNumber = 3;
  bool hidden() const;
  void set_hidden(bool value);

  // int64 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int64 size() const;
  void set_size(::google::protobuf::int64 value);

  // int64 modified_time = 5;
  void clear_modified_time();
  static const int kModifiedTimeFieldNumber = 5;
  ::google::protobuf::int64 modified_time() const;
  void set_modified_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:FileEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  bool hidden_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 modified_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileDirectory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileDirectory) */ {
 public:
  FileDirectory();
  virtual ~FileDirectory();

  FileDirectory(const FileDirectory& from);

  inline FileDirectory& operator=(const FileDirectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileDirectory(FileDirectory&& from) noexcept
    : FileDirectory() {
    *this = ::std::move(from);
  }

  inline FileDirectory& operator=(FileDirectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileDirectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileDirectory* internal_default_instance() {
    return reinterpret_cast<const FileDirectory*>(
               &_FileDirectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(FileDirectory* other);
  friend void swap(FileDirectory& a, FileDirectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileDirectory* New() const final {
    return CreateMaybeMessage<FileDirectory>(nullptr);
  }

  FileDirectory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileDirectory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileDirectory& from);
  void MergeFrom(const FileDirectory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileDirectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FileEntry entries = 3;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 3;
  ::FileEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::FileEntry >*
      mutable_entries();
  const ::FileEntry& entries(int index) const;
  ::FileEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::FileEntry >&
      entries() const;

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileDirectory)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::FileEntry > entries_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ReadDirFiles final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReadDirFiles) */ {
 public:
  ReadDirFiles();
  virtual ~ReadDirFiles();

  ReadDirFiles(const ReadDirFiles& from);

  inline ReadDirFiles& operator=(const ReadDirFiles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadDirFiles(ReadDirFiles&& from) noexcept
    : ReadDirFiles() {
    *this = ::std::move(from);
  }

  inline ReadDirFiles& operator=(ReadDirFiles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReadDirFiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadDirFiles* internal_default_instance() {
    return reinterpret_cast<const ReadDirFiles*>(
               &_ReadDirFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ReadDirFiles* other);
  friend void swap(ReadDirFiles& a, ReadDirFiles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadDirFiles* New() const final {
    return CreateMaybeMessage<ReadDirFiles>(nullptr);
  }

  ReadDirFiles* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadDirFiles>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadDirFiles& from);
  void MergeFrom(const ReadDirFiles& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadDirFiles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // bool include_hidden = 3;
  void clear_include_hidden();
  static const int kIncludeHiddenFieldNumber = 3;
  bool include_hidden() const;
  void set_include_hidden(bool value);

  // bool recursive = 4;
  void clear_recursive();
  static const int kRecursiveFieldNumber = 4;
  bool recursive() const;
  void set_recursive(bool value);

  // @@protoc_insertion_point(class_scope:ReadDirFiles)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  bool include_hidden_;
  bool recursive_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileRemove final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileRemove) */ {
 public:
  FileRemove();
  virtual ~FileRemove();

  FileRemove(const FileRemove& from);

  inline FileRemove& operator=(const FileRemove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileRemove(FileRemove&& from) noexcept
    : FileRemove() {
    *this = ::std::move(from);
  }

  inline FileRemove& operator=(FileRemove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileRemove& default_instance();

  enum UnionCase {
    kRecursive = 3,
    kFileNum = 4,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileRemove* internal_default_instance() {
    return reinterpret_cast<const FileRemove*>(
               &_FileRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(FileRemove* other);
  friend void swap(FileRemove& a, FileRemove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileRemove* New() const final {
    return CreateMaybeMessage<FileRemove>(nullptr);
  }

  FileRemove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileRemove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileRemove& from);
  void MergeFrom(const FileRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRemove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // bool recursive = 3;
  private:
  bool has_recursive() const;
  public:
  void clear_recursive();
  static const int kRecursiveFieldNumber = 3;
  bool recursive() const;
  void set_recursive(bool value);

  // uint32 file_num = 4;
  private:
  bool has_file_num() const;
  public:
  void clear_file_num();
  static const int kFileNumFieldNumber = 4;
  ::google::protobuf::uint32 file_num() const;
  void set_file_num(::google::protobuf::uint32 value);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:FileRemove)
 private:
  class HasBitSetters;
  void set_has_recursive();
  void set_has_file_num();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  union UnionUnion {
    UnionUnion() {}
    bool recursive_;
    ::google::protobuf::uint32 file_num_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileRename final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileRename) */ {
 public:
  FileRename();
  virtual ~FileRename();

  FileRename(const FileRename& from);

  inline FileRename& operator=(const FileRename& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileRename(FileRename&& from) noexcept
    : FileRename() {
    *this = ::std::move(from);
  }

  inline FileRename& operator=(FileRename&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileRename& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileRename* internal_default_instance() {
    return reinterpret_cast<const FileRename*>(
               &_FileRename_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(FileRename* other);
  friend void swap(FileRename& a, FileRename& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileRename* New() const final {
    return CreateMaybeMessage<FileRename>(nullptr);
  }

  FileRename* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileRename>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileRename& from);
  void MergeFrom(const FileRename& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRename* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileRename)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileCreate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileCreate) */ {
 public:
  FileCreate();
  virtual ~FileCreate();

  FileCreate(const FileCreate& from);

  inline FileCreate& operator=(const FileCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileCreate(FileCreate&& from) noexcept
    : FileCreate() {
    *this = ::std::move(from);
  }

  inline FileCreate& operator=(FileCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileCreate* internal_default_instance() {
    return reinterpret_cast<const FileCreate*>(
               &_FileCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FileCreate* other);
  friend void swap(FileCreate& a, FileCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileCreate* New() const final {
    return CreateMaybeMessage<FileCreate>(nullptr);
  }

  FileCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileCreate& from);
  void MergeFrom(const FileCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // bool is_dir = 3;
  void clear_is_dir();
  static const int kIsDirFieldNumber = 3;
  bool is_dir() const;
  void set_is_dir(bool value);

  // @@protoc_insertion_point(class_scope:FileCreate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  bool is_dir_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileAction) */ {
 public:
  FileAction();
  virtual ~FileAction();

  FileAction(const FileAction& from);

  inline FileAction& operator=(const FileAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileAction(FileAction&& from) noexcept
    : FileAction() {
    *this = ::std::move(from);
  }

  inline FileAction& operator=(FileAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileAction& default_instance();

  enum UnionCase {
    kReadFiles = 1,
    kCreate = 2,
    kRemove = 3,
    kRename = 4,
    kTransfer = 5,
    kCancel = 6,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileAction* internal_default_instance() {
    return reinterpret_cast<const FileAction*>(
               &_FileAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(FileAction* other);
  friend void swap(FileAction& a, FileAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileAction* New() const final {
    return CreateMaybeMessage<FileAction>(nullptr);
  }

  FileAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileAction& from);
  void MergeFrom(const FileAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ReadDirFiles read_files = 1;
  bool has_read_files() const;
  void clear_read_files();
  static const int kReadFilesFieldNumber = 1;
  const ::ReadDirFiles& read_files() const;
  ::ReadDirFiles* release_read_files();
  ::ReadDirFiles* mutable_read_files();
  void set_allocated_read_files(::ReadDirFiles* read_files);

  // .FileCreate create = 2;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 2;
  const ::FileCreate& create() const;
  ::FileCreate* release_create();
  ::FileCreate* mutable_create();
  void set_allocated_create(::FileCreate* create);

  // .FileRemove remove = 3;
  bool has_remove() const;
  void clear_remove();
  static const int kRemoveFieldNumber = 3;
  const ::FileRemove& remove() const;
  ::FileRemove* release_remove();
  ::FileRemove* mutable_remove();
  void set_allocated_remove(::FileRemove* remove);

  // .FileRename rename = 4;
  bool has_rename() const;
  void clear_rename();
  static const int kRenameFieldNumber = 4;
  const ::FileRename& rename() const;
  ::FileRename* release_rename();
  ::FileRename* mutable_rename();
  void set_allocated_rename(::FileRename* rename);

  // .FileTransferRequest transfer = 5;
  bool has_transfer() const;
  void clear_transfer();
  static const int kTransferFieldNumber = 5;
  const ::FileTransferRequest& transfer() const;
  ::FileTransferRequest* release_transfer();
  ::FileTransferRequest* mutable_transfer();
  void set_allocated_transfer(::FileTransferRequest* transfer);

  // .FileTransferCancel cancel = 6;
  bool has_cancel() const;
  void clear_cancel();
  static const int kCancelFieldNumber = 6;
  const ::FileTransferCancel& cancel() const;
  ::FileTransferCancel* release_cancel();
  ::FileTransferCancel* mutable_cancel();
  void set_allocated_cancel(::FileTransferCancel* cancel);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:FileAction)
 private:
  class HasBitSetters;
  void set_has_read_files();
  void set_has_create();
  void set_has_remove();
  void set_has_rename();
  void set_has_transfer();
  void set_has_cancel();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union UnionUnion {
    UnionUnion() {}
    ::ReadDirFiles* read_files_;
    ::FileCreate* create_;
    ::FileRemove* remove_;
    ::FileRename* rename_;
    ::FileTransferRequest* transfer_;
    ::FileTransferCancel* cancel_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransferCancel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransferCancel) */ {
 public:
  FileTransferCancel();
  virtual ~FileTransferCancel();

  FileTransferCancel(const FileTransferCancel& from);

  inline FileTransferCancel& operator=(const FileTransferCancel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransferCancel(FileTransferCancel&& from) noexcept
    : FileTransferCancel() {
    *this = ::std::move(from);
  }

  inline FileTransferCancel& operator=(FileTransferCancel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransferCancel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransferCancel* internal_default_instance() {
    return reinterpret_cast<const FileTransferCancel*>(
               &_FileTransferCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(FileTransferCancel* other);
  friend void swap(FileTransferCancel& a, FileTransferCancel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransferCancel* New() const final {
    return CreateMaybeMessage<FileTransferCancel>(nullptr);
  }

  FileTransferCancel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransferCancel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransferCancel& from);
  void MergeFrom(const FileTransferCancel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferCancel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileTransferCancel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileResponse) */ {
 public:
  FileResponse();
  virtual ~FileResponse();

  FileResponse(const FileResponse& from);

  inline FileResponse& operator=(const FileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileResponse(FileResponse&& from) noexcept
    : FileResponse() {
    *this = ::std::move(from);
  }

  inline FileResponse& operator=(FileResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileResponse& default_instance();

  enum UnionCase {
    kDir = 1,
    kConfirm = 2,
    kBlock = 3,
    kDigest = 4,
    kError = 5,
    kDone = 6,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileResponse* internal_default_instance() {
    return reinterpret_cast<const FileResponse*>(
               &_FileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(FileResponse* other);
  friend void swap(FileResponse& a, FileResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileResponse* New() const final {
    return CreateMaybeMessage<FileResponse>(nullptr);
  }

  FileResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileResponse& from);
  void MergeFrom(const FileResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .FileDirectory dir = 1;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 1;
  const ::FileDirectory& dir() const;
  ::FileDirectory* release_dir();
  ::FileDirectory* mutable_dir();
  void set_allocated_dir(::FileDirectory* dir);

  // .FileTransferConfirm confirm = 2;
  bool has_confirm() const;
  void clear_confirm();
  static const int kConfirmFieldNumber = 2;
  const ::FileTransferConfirm& confirm() const;
  ::FileTransferConfirm* release_confirm();
  ::FileTransferConfirm* mutable_confirm();
  void set_allocated_confirm(::FileTransferConfirm* confirm);

  // .FileTransferBlock block = 3;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 3;
  const ::FileTransferBlock& block() const;
  ::FileTransferBlock* release_block();
  ::FileTransferBlock* mutable_block();
  void set_allocated_block(::FileTransferBlock* block);

  // .FileTransferDigest digest = 4;
  bool has_digest() const;
  void clear_digest();
  static const int kDigestFieldNumber = 4;
  const ::FileTransferDigest& digest() const;
  ::FileTransferDigest* release_digest();
  ::FileTransferDigest* mutable_digest();
  void set_allocated_digest(::FileTransferDigest* digest);

  // .FileTransferError error = 5;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 5;
  const ::FileTransferError& error() const;
  ::FileTransferError* release_error();
  ::FileTransferError* mutable_error();
  void set_allocated_error(::FileTransferError* error);

  // .FileTransferDone done = 6;
  bool has_done() const;
  void clear_done();
  static const int kDoneFieldNumber = 6;
  const ::FileTransferDone& done() const;
  ::FileTransferDone* release_done();
  ::FileTransferDone* mutable_done();
  void set_allocated_done(::FileTransferDone* done);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:FileResponse)
 private:
  class HasBitSetters;
  void set_has_dir();
  void set_has_confirm();
  void set_has_block();
  void set_has_digest();
  void set_has_error();
  void set_has_done();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union UnionUnion {
    UnionUnion() {}
    ::FileDirectory* dir_;
    ::FileTransferConfirm* confirm_;
    ::FileTransferBlock* block_;
    ::FileTransferDigest* digest_;
    ::FileTransferError* error_;
    ::FileTransferDone* done_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransferConfirm final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransferConfirm) */ {
 public:
  FileTransferConfirm();
  virtual ~FileTransferConfirm();

  FileTransferConfirm(const FileTransferConfirm& from);

  inline FileTransferConfirm& operator=(const FileTransferConfirm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransferConfirm(FileTransferConfirm&& from) noexcept
    : FileTransferConfirm() {
    *this = ::std::move(from);
  }

  inline FileTransferConfirm& operator=(FileTransferConfirm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransferConfirm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransferConfirm* internal_default_instance() {
    return reinterpret_cast<const FileTransferConfirm*>(
               &_FileTransferConfirm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(FileTransferConfirm* other);
  friend void swap(FileTransferConfirm& a, FileTransferConfirm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransferConfirm* New() const final {
    return CreateMaybeMessage<FileTransferConfirm>(nullptr);
  }

  FileTransferConfirm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransferConfirm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransferConfirm& from);
  void MergeFrom(const FileTransferConfirm& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferConfirm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileTransferConfirm)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransferBlock final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransferBlock) */ {
 public:
  FileTransferBlock();
  virtual ~FileTransferBlock();

  FileTransferBlock(const FileTransferBlock& from);

  inline FileTransferBlock& operator=(const FileTransferBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransferBlock(FileTransferBlock&& from) noexcept
    : FileTransferBlock() {
    *this = ::std::move(from);
  }

  inline FileTransferBlock& operator=(FileTransferBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransferBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransferBlock* internal_default_instance() {
    return reinterpret_cast<const FileTransferBlock*>(
               &_FileTransferBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(FileTransferBlock* other);
  friend void swap(FileTransferBlock& a, FileTransferBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransferBlock* New() const final {
    return CreateMaybeMessage<FileTransferBlock>(nullptr);
  }

  FileTransferBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransferBlock>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransferBlock& from);
  void MergeFrom(const FileTransferBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // uint32 file_num = 2;
  void clear_file_num();
  static const int kFileNumFieldNumber = 2;
  ::google::protobuf::uint32 file_num() const;
  void set_file_num(::google::protobuf::uint32 value);

  // bool compressed = 4;
  void clear_compressed();
  static const int kCompressedFieldNumber = 4;
  bool compressed() const;
  void set_compressed(bool value);

  // uint32 blk_id = 5;
  void clear_blk_id();
  static const int kBlkIdFieldNumber = 5;
  ::google::protobuf::uint32 blk_id() const;
  void set_blk_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:FileTransferBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 file_num_;
  bool compressed_;
  ::google::protobuf::uint32 blk_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransferDigest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransferDigest) */ {
 public:
  FileTransferDigest();
  virtual ~FileTransferDigest();

  FileTransferDigest(const FileTransferDigest& from);

  inline FileTransferDigest& operator=(const FileTransferDigest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransferDigest(FileTransferDigest&& from) noexcept
    : FileTransferDigest() {
    *this = ::std::move(from);
  }

  inline FileTransferDigest& operator=(FileTransferDigest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransferDigest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransferDigest* internal_default_instance() {
    return reinterpret_cast<const FileTransferDigest*>(
               &_FileTransferDigest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(FileTransferDigest* other);
  friend void swap(FileTransferDigest& a, FileTransferDigest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransferDigest* New() const final {
    return CreateMaybeMessage<FileTransferDigest>(nullptr);
  }

  FileTransferDigest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransferDigest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransferDigest& from);
  void MergeFrom(const FileTransferDigest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferDigest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string blk_md5 = 3;
  void clear_blk_md5();
  static const int kBlkMd5FieldNumber = 3;
  const ::std::string& blk_md5() const;
  void set_blk_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_blk_md5(::std::string&& value);
  #endif
  void set_blk_md5(const char* value);
  void set_blk_md5(const char* value, size_t size);
  ::std::string* mutable_blk_md5();
  ::std::string* release_blk_md5();
  void set_allocated_blk_md5(::std::string* blk_md5);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // uint32 blk_id = 2;
  void clear_blk_id();
  static const int kBlkIdFieldNumber = 2;
  ::google::protobuf::uint32 blk_id() const;
  void set_blk_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:FileTransferDigest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr blk_md5_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 blk_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransferError final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransferError) */ {
 public:
  FileTransferError();
  virtual ~FileTransferError();

  FileTransferError(const FileTransferError& from);

  inline FileTransferError& operator=(const FileTransferError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransferError(FileTransferError&& from) noexcept
    : FileTransferError() {
    *this = ::std::move(from);
  }

  inline FileTransferError& operator=(FileTransferError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransferError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransferError* internal_default_instance() {
    return reinterpret_cast<const FileTransferError*>(
               &_FileTransferError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(FileTransferError* other);
  friend void swap(FileTransferError& a, FileTransferError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransferError* New() const final {
    return CreateMaybeMessage<FileTransferError>(nullptr);
  }

  FileTransferError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransferError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransferError& from);
  void MergeFrom(const FileTransferError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // uint32 file_num = 3;
  void clear_file_num();
  static const int kFileNumFieldNumber = 3;
  ::google::protobuf::uint32 file_num() const;
  void set_file_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:FileTransferError)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 file_num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransferDone final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransferDone) */ {
 public:
  FileTransferDone();
  virtual ~FileTransferDone();

  FileTransferDone(const FileTransferDone& from);

  inline FileTransferDone& operator=(const FileTransferDone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransferDone(FileTransferDone&& from) noexcept
    : FileTransferDone() {
    *this = ::std::move(from);
  }

  inline FileTransferDone& operator=(FileTransferDone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransferDone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransferDone* internal_default_instance() {
    return reinterpret_cast<const FileTransferDone*>(
               &_FileTransferDone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(FileTransferDone* other);
  friend void swap(FileTransferDone& a, FileTransferDone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransferDone* New() const final {
    return CreateMaybeMessage<FileTransferDone>(nullptr);
  }

  FileTransferDone* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransferDone>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransferDone& from);
  void MergeFrom(const FileTransferDone& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferDone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // uint32 file_num = 2;
  void clear_file_num();
  static const int kFileNumFieldNumber = 2;
  ::google::protobuf::uint32 file_num() const;
  void set_file_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:FileTransferDone)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 file_num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransferRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransferRequest) */ {
 public:
  FileTransferRequest();
  virtual ~FileTransferRequest();

  FileTransferRequest(const FileTransferRequest& from);

  inline FileTransferRequest& operator=(const FileTransferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransferRequest(FileTransferRequest&& from) noexcept
    : FileTransferRequest() {
    *this = ::std::move(from);
  }

  inline FileTransferRequest& operator=(FileTransferRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransferRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransferRequest* internal_default_instance() {
    return reinterpret_cast<const FileTransferRequest*>(
               &_FileTransferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(FileTransferRequest* other);
  friend void swap(FileTransferRequest& a, FileTransferRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransferRequest* New() const final {
    return CreateMaybeMessage<FileTransferRequest>(nullptr);
  }

  FileTransferRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransferRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransferRequest& from);
  void MergeFrom(const FileTransferRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FileTransferRequest_Direction Direction;
  static const Direction NotSet =
    FileTransferRequest_Direction_NotSet;
  static const Direction Send =
    FileTransferRequest_Direction_Send;
  static const Direction Receive =
    FileTransferRequest_Direction_Receive;
  static inline bool Direction_IsValid(int value) {
    return FileTransferRequest_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    FileTransferRequest_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    FileTransferRequest_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    FileTransferRequest_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return FileTransferRequest_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return FileTransferRequest_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return FileTransferRequest_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // uint32 file_num = 3;
  void clear_file_num();
  static const int kFileNumFieldNumber = 3;
  ::google::protobuf::uint32 file_num() const;
  void set_file_num(::google::protobuf::uint32 value);

  // bool include_hidden = 4;
  void clear_include_hidden();
  static const int kIncludeHiddenFieldNumber = 4;
  bool include_hidden() const;
  void set_include_hidden(bool value);

  // .FileTransferRequest.Direction ask = 5;
  void clear_ask();
  static const int kAskFieldNumber = 5;
  ::FileTransferRequest_Direction ask() const;
  void set_ask(::FileTransferRequest_Direction value);

  // @@protoc_insertion_point(class_scope:FileTransferRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 file_num_;
  bool include_hidden_;
  int ask_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransResponse) */ {
 public:
  FileTransResponse();
  virtual ~FileTransResponse();

  FileTransResponse(const FileTransResponse& from);

  inline FileTransResponse& operator=(const FileTransResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransResponse(FileTransResponse&& from) noexcept
    : FileTransResponse() {
    *this = ::std::move(from);
  }

  inline FileTransResponse& operator=(FileTransResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransResponse* internal_default_instance() {
    return reinterpret_cast<const FileTransResponse*>(
               &_FileTransResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(FileTransResponse* other);
  friend void swap(FileTransResponse& a, FileTransResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransResponse* New() const final {
    return CreateMaybeMessage<FileTransResponse>(nullptr);
  }

  FileTransResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransResponse& from);
  void MergeFrom(const FileTransResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // .FileTransRe result = 3;
  void clear_result();
  static const int kResultFieldNumber = 3;
  ::FileTransRe result() const;
  void set_result(::FileTransRe value);

  // @@protoc_insertion_point(class_scope:FileTransResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  int result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransJob final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransJob) */ {
 public:
  FileTransJob();
  virtual ~FileTransJob();

  FileTransJob(const FileTransJob& from);

  inline FileTransJob& operator=(const FileTransJob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransJob(FileTransJob&& from) noexcept
    : FileTransJob() {
    *this = ::std::move(from);
  }

  inline FileTransJob& operator=(FileTransJob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransJob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransJob* internal_default_instance() {
    return reinterpret_cast<const FileTransJob*>(
               &_FileTransJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(FileTransJob* other);
  friend void swap(FileTransJob& a, FileTransJob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransJob* New() const final {
    return CreateMaybeMessage<FileTransJob>(nullptr);
  }

  FileTransJob* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransJob>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransJob& from);
  void MergeFrom(const FileTransJob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransJob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string app_who = 6;
  void clear_app_who();
  static const int kAppWhoFieldNumber = 6;
  const ::std::string& app_who() const;
  void set_app_who(const ::std::string& value);
  #if LANG_CXX11
  void set_app_who(::std::string&& value);
  #endif
  void set_app_who(const char* value);
  void set_app_who(const char* value, size_t size);
  ::std::string* mutable_app_who();
  ::std::string* release_app_who();
  void set_allocated_app_who(::std::string* app_who);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // bool include_hidden = 3;
  void clear_include_hidden();
  static const int kIncludeHiddenFieldNumber = 3;
  bool include_hidden() const;
  void set_include_hidden(bool value);

  // bool recursive = 4;
  void clear_recursive();
  static const int kRecursiveFieldNumber = 4;
  bool recursive() const;
  void set_recursive(bool value);

  // bool push = 5;
  void clear_push();
  static const int kPushFieldNumber = 5;
  bool push() const;
  void set_push(bool value);

  // @@protoc_insertion_point(class_scope:FileTransJob)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr app_who_;
  ::google::protobuf::int32 job_id_;
  bool include_hidden_;
  bool recursive_;
  bool push_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransCreate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransCreate) */ {
 public:
  FileTransCreate();
  virtual ~FileTransCreate();

  FileTransCreate(const FileTransCreate& from);

  inline FileTransCreate& operator=(const FileTransCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransCreate(FileTransCreate&& from) noexcept
    : FileTransCreate() {
    *this = ::std::move(from);
  }

  inline FileTransCreate& operator=(FileTransCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransCreate* internal_default_instance() {
    return reinterpret_cast<const FileTransCreate*>(
               &_FileTransCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(FileTransCreate* other);
  friend void swap(FileTransCreate& a, FileTransCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransCreate* New() const final {
    return CreateMaybeMessage<FileTransCreate>(nullptr);
  }

  FileTransCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransCreate& from);
  void MergeFrom(const FileTransCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sub_dir = 3;
  void clear_sub_dir();
  static const int kSubDirFieldNumber = 3;
  const ::std::string& sub_dir() const;
  void set_sub_dir(const ::std::string& value);
  #if LANG_CXX11
  void set_sub_dir(::std::string&& value);
  #endif
  void set_sub_dir(const char* value);
  void set_sub_dir(const char* value, size_t size);
  ::std::string* mutable_sub_dir();
  ::std::string* release_sub_dir();
  void set_allocated_sub_dir(::std::string* sub_dir);

  // .FileEntry entry = 4;
  bool has_entry() const;
  void clear_entry();
  static const int kEntryFieldNumber = 4;
  const ::FileEntry& entry() const;
  ::FileEntry* release_entry();
  ::FileEntry* mutable_entry();
  void set_allocated_entry(::FileEntry* entry);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // int32 file_id = 2;
  void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  ::google::protobuf::int32 file_id() const;
  void set_file_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileTransCreate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sub_dir_;
  ::FileEntry* entry_;
  ::google::protobuf::int32 job_id_;
  ::google::protobuf::int32 file_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransBlock final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransBlock) */ {
 public:
  FileTransBlock();
  virtual ~FileTransBlock();

  FileTransBlock(const FileTransBlock& from);

  inline FileTransBlock& operator=(const FileTransBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransBlock(FileTransBlock&& from) noexcept
    : FileTransBlock() {
    *this = ::std::move(from);
  }

  inline FileTransBlock& operator=(FileTransBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransBlock* internal_default_instance() {
    return reinterpret_cast<const FileTransBlock*>(
               &_FileTransBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(FileTransBlock* other);
  friend void swap(FileTransBlock& a, FileTransBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransBlock* New() const final {
    return CreateMaybeMessage<FileTransBlock>(nullptr);
  }

  FileTransBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransBlock>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransBlock& from);
  void MergeFrom(const FileTransBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 3;
  void clear_filename();
  static const int kFilenameFieldNumber = 3;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // bytes data = 5;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // int32 file_id = 2;
  void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  ::google::protobuf::int32 file_id() const;
  void set_file_id(::google::protobuf::int32 value);

  // uint32 blk_id = 4;
  void clear_blk_id();
  static const int kBlkIdFieldNumber = 4;
  ::google::protobuf::uint32 blk_id() const;
  void set_blk_id(::google::protobuf::uint32 value);

  // bool compressed = 6;
  void clear_compressed();
  static const int kCompressedFieldNumber = 6;
  bool compressed() const;
  void set_compressed(bool value);

  // @@protoc_insertion_point(class_scope:FileTransBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 job_id_;
  ::google::protobuf::int32 file_id_;
  ::google::protobuf::uint32 blk_id_;
  bool compressed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransJobCancel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransJobCancel) */ {
 public:
  FileTransJobCancel();
  virtual ~FileTransJobCancel();

  FileTransJobCancel(const FileTransJobCancel& from);

  inline FileTransJobCancel& operator=(const FileTransJobCancel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransJobCancel(FileTransJobCancel&& from) noexcept
    : FileTransJobCancel() {
    *this = ::std::move(from);
  }

  inline FileTransJobCancel& operator=(FileTransJobCancel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransJobCancel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransJobCancel* internal_default_instance() {
    return reinterpret_cast<const FileTransJobCancel*>(
               &_FileTransJobCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(FileTransJobCancel* other);
  friend void swap(FileTransJobCancel& a, FileTransJobCancel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransJobCancel* New() const final {
    return CreateMaybeMessage<FileTransJobCancel>(nullptr);
  }

  FileTransJobCancel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransJobCancel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransJobCancel& from);
  void MergeFrom(const FileTransJobCancel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransJobCancel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileTransJobCancel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 job_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransJobReport final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransJobReport) */ {
 public:
  FileTransJobReport();
  virtual ~FileTransJobReport();

  FileTransJobReport(const FileTransJobReport& from);

  inline FileTransJobReport& operator=(const FileTransJobReport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransJobReport(FileTransJobReport&& from) noexcept
    : FileTransJobReport() {
    *this = ::std::move(from);
  }

  inline FileTransJobReport& operator=(FileTransJobReport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransJobReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransJobReport* internal_default_instance() {
    return reinterpret_cast<const FileTransJobReport*>(
               &_FileTransJobReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(FileTransJobReport* other);
  friend void swap(FileTransJobReport& a, FileTransJobReport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransJobReport* New() const final {
    return CreateMaybeMessage<FileTransJobReport>(nullptr);
  }

  FileTransJobReport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransJobReport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransJobReport& from);
  void MergeFrom(const FileTransJobReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransJobReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string error = 3;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // .FileTransRe result = 4;
  void clear_result();
  static const int kResultFieldNumber = 4;
  ::FileTransRe result() const;
  void set_result(::FileTransRe value);

  // @@protoc_insertion_point(class_scope:FileTransJobReport)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::int32 job_id_;
  int result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransUpdate) */ {
 public:
  FileTransUpdate();
  virtual ~FileTransUpdate();

  FileTransUpdate(const FileTransUpdate& from);

  inline FileTransUpdate& operator=(const FileTransUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransUpdate(FileTransUpdate&& from) noexcept
    : FileTransUpdate() {
    *this = ::std::move(from);
  }

  inline FileTransUpdate& operator=(FileTransUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransUpdate& default_instance();

  enum UnionCase {
    kCancel = 1,
    kReport = 2,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransUpdate* internal_default_instance() {
    return reinterpret_cast<const FileTransUpdate*>(
               &_FileTransUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(FileTransUpdate* other);
  friend void swap(FileTransUpdate& a, FileTransUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransUpdate* New() const final {
    return CreateMaybeMessage<FileTransUpdate>(nullptr);
  }

  FileTransUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransUpdate& from);
  void MergeFrom(const FileTransUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .FileTransJobCancel cancel = 1;
  bool has_cancel() const;
  void clear_cancel();
  static const int kCancelFieldNumber = 1;
  const ::FileTransJobCancel& cancel() const;
  ::FileTransJobCancel* release_cancel();
  ::FileTransJobCancel* mutable_cancel();
  void set_allocated_cancel(::FileTransJobCancel* cancel);

  // .FileTransJobReport report = 2;
  bool has_report() const;
  void clear_report();
  static const int kReportFieldNumber = 2;
  const ::FileTransJobReport& report() const;
  ::FileTransJobReport* release_report();
  ::FileTransJobReport* mutable_report();
  void set_allocated_report(::FileTransJobReport* report);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:FileTransUpdate)
 private:
  class HasBitSetters;
  void set_has_cancel();
  void set_has_report();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union UnionUnion {
    UnionUnion() {}
    ::FileTransJobCancel* cancel_;
    ::FileTransJobReport* report_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Misc final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Misc) */ {
 public:
  Misc();
  virtual ~Misc();

  Misc(const Misc& from);

  inline Misc& operator=(const Misc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Misc(Misc&& from) noexcept
    : Misc() {
    *this = ::std::move(from);
  }

  inline Misc& operator=(Misc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Misc& default_instance();

  enum UnionCase {
    kChatMessage = 1,
    kPermissionInfo = 2,
    kOption = 3,
    kCloseReason = 4,
    kStopService = 5,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Misc* internal_default_instance() {
    return reinterpret_cast<const Misc*>(
               &_Misc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(Misc* other);
  friend void swap(Misc& a, Misc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Misc* New() const final {
    return CreateMaybeMessage<Misc>(nullptr);
  }

  Misc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Misc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Misc& from);
  void MergeFrom(const Misc& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Misc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ChatMessage chat_message = 1;
  bool has_chat_message() const;
  void clear_chat_message();
  static const int kChatMessageFieldNumber = 1;
  const ::ChatMessage& chat_message() const;
  ::ChatMessage* release_chat_message();
  ::ChatMessage* mutable_chat_message();
  void set_allocated_chat_message(::ChatMessage* chat_message);

  // .PermissionInfo permission_info = 2;
  bool has_permission_info() const;
  void clear_permission_info();
  static const int kPermissionInfoFieldNumber = 2;
  const ::PermissionInfo& permission_info() const;
  ::PermissionInfo* release_permission_info();
  ::PermissionInfo* mutable_permission_info();
  void set_allocated_permission_info(::PermissionInfo* permission_info);

  // .OptionMessage option = 3;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 3;
  const ::OptionMessage& option() const;
  ::OptionMessage* release_option();
  ::OptionMessage* mutable_option();
  void set_allocated_option(::OptionMessage* option);

  // string close_reason = 4;
  private:
  bool has_close_reason() const;
  public:
  void clear_close_reason();
  static const int kCloseReasonFieldNumber = 4;
  const ::std::string& close_reason() const;
  void set_close_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_close_reason(::std::string&& value);
  #endif
  void set_close_reason(const char* value);
  void set_close_reason(const char* value, size_t size);
  ::std::string* mutable_close_reason();
  ::std::string* release_close_reason();
  void set_allocated_close_reason(::std::string* close_reason);

  // bool stop_service = 5;
  private:
  bool has_stop_service() const;
  public:
  void clear_stop_service();
  static const int kStopServiceFieldNumber = 5;
  bool stop_service() const;
  void set_stop_service(bool value);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:Misc)
 private:
  class HasBitSetters;
  void set_has_chat_message();
  void set_has_permission_info();
  void set_has_option();
  void set_has_close_reason();
  void set_has_stop_service();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union UnionUnion {
    UnionUnion() {}
    ::ChatMessage* chat_message_;
    ::PermissionInfo* permission_info_;
    ::OptionMessage* option_;
    ::google::protobuf::internal::ArenaStringPtr close_reason_;
    bool stop_service_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================

class RemoteService_Stub;

class RemoteService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline RemoteService() {};
 public:
  virtual ~RemoteService();

  typedef RemoteService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void login(::google::protobuf::RpcController* controller,
                       const ::LoginRequest* request,
                       ::LoginResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void query_peerinfo(::google::protobuf::RpcController* controller,
                       const ::PeerInfo* request,
                       ::PeerInfo* response,
                       ::google::protobuf::Closure* done);
  virtual void misc(::google::protobuf::RpcController* controller,
                       const ::Misc* request,
                       ::Misc* response,
                       ::google::protobuf::Closure* done);
  virtual void fsaction(::google::protobuf::RpcController* controller,
                       const ::FileAction* request,
                       ::FileResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void fsflow(::google::protobuf::RpcController* controller,
                       const ::FileResponse* request,
                       ::FileResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void filetrans_job(::google::protobuf::RpcController* controller,
                       const ::FileTransJob* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void filetrans_create(::google::protobuf::RpcController* controller,
                       const ::FileTransCreate* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void filetrans_block(::google::protobuf::RpcController* controller,
                       const ::FileTransBlock* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void filetrans_update(::google::protobuf::RpcController* controller,
                       const ::FileTransUpdate* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RemoteService);
};

class RemoteService_Stub : public RemoteService {
 public:
  RemoteService_Stub(::google::protobuf::RpcChannel* channel);
  RemoteService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~RemoteService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements RemoteService ------------------------------------------

  void login(::google::protobuf::RpcController* controller,
                       const ::LoginRequest* request,
                       ::LoginResponse* response,
                       ::google::protobuf::Closure* done);
  void query_peerinfo(::google::protobuf::RpcController* controller,
                       const ::PeerInfo* request,
                       ::PeerInfo* response,
                       ::google::protobuf::Closure* done);
  void misc(::google::protobuf::RpcController* controller,
                       const ::Misc* request,
                       ::Misc* response,
                       ::google::protobuf::Closure* done);
  void fsaction(::google::protobuf::RpcController* controller,
                       const ::FileAction* request,
                       ::FileResponse* response,
                       ::google::protobuf::Closure* done);
  void fsflow(::google::protobuf::RpcController* controller,
                       const ::FileResponse* request,
                       ::FileResponse* response,
                       ::google::protobuf::Closure* done);
  void filetrans_job(::google::protobuf::RpcController* controller,
                       const ::FileTransJob* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  void filetrans_create(::google::protobuf::RpcController* controller,
                       const ::FileTransCreate* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  void filetrans_block(::google::protobuf::RpcController* controller,
                       const ::FileTransBlock* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  void filetrans_update(::google::protobuf::RpcController* controller,
                       const ::FileTransUpdate* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RemoteService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// string name = 1;
inline void LoginRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::name() const {
  // @@protoc_insertion_point(field_get:LoginRequest.name)
  return name_.GetNoArena();
}
inline void LoginRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.name)
}
#if LANG_CXX11
inline void LoginRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.name)
}
#endif
inline void LoginRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.name)
}
inline void LoginRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.name)
}
inline ::std::string* LoginRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_name() {
  // @@protoc_insertion_point(field_release:LoginRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.name)
}

// bytes auth = 2;
inline void LoginRequest::clear_auth() {
  auth_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::auth() const {
  // @@protoc_insertion_point(field_get:LoginRequest.auth)
  return auth_.GetNoArena();
}
inline void LoginRequest::set_auth(const ::std::string& value) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.auth)
}
#if LANG_CXX11
inline void LoginRequest::set_auth(::std::string&& value) {
  
  auth_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.auth)
}
#endif
inline void LoginRequest::set_auth(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.auth)
}
inline void LoginRequest::set_auth(const void* value, size_t size) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.auth)
}
inline ::std::string* LoginRequest::mutable_auth() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.auth)
  return auth_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_auth() {
  // @@protoc_insertion_point(field_release:LoginRequest.auth)
  
  return auth_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_auth(::std::string* auth) {
  if (auth != nullptr) {
    
  } else {
    
  }
  auth_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.auth)
}

// string my_uid = 4;
inline void LoginRequest::clear_my_uid() {
  my_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::my_uid() const {
  // @@protoc_insertion_point(field_get:LoginRequest.my_uid)
  return my_uid_.GetNoArena();
}
inline void LoginRequest::set_my_uid(const ::std::string& value) {
  
  my_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.my_uid)
}
#if LANG_CXX11
inline void LoginRequest::set_my_uid(::std::string&& value) {
  
  my_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.my_uid)
}
#endif
inline void LoginRequest::set_my_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  my_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.my_uid)
}
inline void LoginRequest::set_my_uid(const char* value, size_t size) {
  
  my_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.my_uid)
}
inline ::std::string* LoginRequest::mutable_my_uid() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.my_uid)
  return my_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_my_uid() {
  // @@protoc_insertion_point(field_release:LoginRequest.my_uid)
  
  return my_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_my_uid(::std::string* my_uid) {
  if (my_uid != nullptr) {
    
  } else {
    
  }
  my_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), my_uid);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.my_uid)
}

// string my_name = 5;
inline void LoginRequest::clear_my_name() {
  my_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::my_name() const {
  // @@protoc_insertion_point(field_get:LoginRequest.my_name)
  return my_name_.GetNoArena();
}
inline void LoginRequest::set_my_name(const ::std::string& value) {
  
  my_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.my_name)
}
#if LANG_CXX11
inline void LoginRequest::set_my_name(::std::string&& value) {
  
  my_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.my_name)
}
#endif
inline void LoginRequest::set_my_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  my_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.my_name)
}
inline void LoginRequest::set_my_name(const char* value, size_t size) {
  
  my_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.my_name)
}
inline ::std::string* LoginRequest::mutable_my_name() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.my_name)
  return my_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_my_name() {
  // @@protoc_insertion_point(field_release:LoginRequest.my_name)
  
  return my_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_my_name(::std::string* my_name) {
  if (my_name != nullptr) {
    
  } else {
    
  }
  my_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), my_name);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.my_name)
}

// .OptionMessage option = 6;
inline bool LoginRequest::has_option() const {
  return this != internal_default_instance() && option_ != nullptr;
}
inline void LoginRequest::clear_option() {
  if (GetArenaNoVirtual() == nullptr && option_ != nullptr) {
    delete option_;
  }
  option_ = nullptr;
}
inline const ::OptionMessage& LoginRequest::option() const {
  const ::OptionMessage* p = option_;
  // @@protoc_insertion_point(field_get:LoginRequest.option)
  return p != nullptr ? *p : *reinterpret_cast<const ::OptionMessage*>(
      &::_OptionMessage_default_instance_);
}
inline ::OptionMessage* LoginRequest::release_option() {
  // @@protoc_insertion_point(field_release:LoginRequest.option)
  
  ::OptionMessage* temp = option_;
  option_ = nullptr;
  return temp;
}
inline ::OptionMessage* LoginRequest::mutable_option() {
  
  if (option_ == nullptr) {
    auto* p = CreateMaybeMessage<::OptionMessage>(GetArenaNoVirtual());
    option_ = p;
  }
  // @@protoc_insertion_point(field_mutable:LoginRequest.option)
  return option_;
}
inline void LoginRequest::set_allocated_option(::OptionMessage* option) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete option_;
  }
  if (option) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      option = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, option, submessage_arena);
    }
    
  } else {
    
  }
  option_ = option;
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.option)
}

// int32 session_id = 7;
inline void LoginRequest::clear_session_id() {
  session_id_ = 0;
}
inline ::google::protobuf::int32 LoginRequest::session_id() const {
  // @@protoc_insertion_point(field_get:LoginRequest.session_id)
  return session_id_;
}
inline void LoginRequest::set_session_id(::google::protobuf::int32 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:LoginRequest.session_id)
}

// string version = 8;
inline void LoginRequest::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::version() const {
  // @@protoc_insertion_point(field_get:LoginRequest.version)
  return version_.GetNoArena();
}
inline void LoginRequest::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.version)
}
#if LANG_CXX11
inline void LoginRequest::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.version)
}
#endif
inline void LoginRequest::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.version)
}
inline void LoginRequest::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.version)
}
inline ::std::string* LoginRequest::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_version() {
  // @@protoc_insertion_point(field_release:LoginRequest.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.version)
}

// -------------------------------------------------------------------

// LoginResponse

// string error = 1;
inline bool LoginResponse::has_error() const {
  return union_case() == kError;
}
inline void LoginResponse::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void LoginResponse::clear_error() {
  if (has_error()) {
    union_.error_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_union();
  }
}
inline const ::std::string& LoginResponse::error() const {
  // @@protoc_insertion_point(field_get:LoginResponse.error)
  if (has_error()) {
    return union_.error_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void LoginResponse::set_error(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:LoginResponse.error)
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginResponse.error)
}
#if LANG_CXX11
inline void LoginResponse::set_error(::std::string&& value) {
  // @@protoc_insertion_point(field_set:LoginResponse.error)
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginResponse.error)
}
#endif
inline void LoginResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginResponse.error)
}
inline void LoginResponse::set_error(const char* value, size_t size) {
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginResponse.error)
}
inline ::std::string* LoginResponse::mutable_error() {
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:LoginResponse.error)
  return union_.error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse::release_error() {
  // @@protoc_insertion_point(field_release:LoginResponse.error)
  if (has_error()) {
    clear_has_union();
    return union_.error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void LoginResponse::set_allocated_error(::std::string* error) {
  if (has_union()) {
    clear_union();
  }
  if (error != nullptr) {
    set_has_error();
    union_.error_.UnsafeSetDefault(error);
  }
  // @@protoc_insertion_point(field_set_allocated:LoginResponse.error)
}

// .PeerInfo peer_info = 2;
inline bool LoginResponse::has_peer_info() const {
  return union_case() == kPeerInfo;
}
inline void LoginResponse::set_has_peer_info() {
  _oneof_case_[0] = kPeerInfo;
}
inline void LoginResponse::clear_peer_info() {
  if (has_peer_info()) {
    delete union_.peer_info_;
    clear_has_union();
  }
}
inline ::PeerInfo* LoginResponse::release_peer_info() {
  // @@protoc_insertion_point(field_release:LoginResponse.peer_info)
  if (has_peer_info()) {
    clear_has_union();
      ::PeerInfo* temp = union_.peer_info_;
    union_.peer_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PeerInfo& LoginResponse::peer_info() const {
  // @@protoc_insertion_point(field_get:LoginResponse.peer_info)
  return has_peer_info()
      ? *union_.peer_info_
      : *reinterpret_cast< ::PeerInfo*>(&::_PeerInfo_default_instance_);
}
inline ::PeerInfo* LoginResponse::mutable_peer_info() {
  if (!has_peer_info()) {
    clear_union();
    set_has_peer_info();
    union_.peer_info_ = CreateMaybeMessage< ::PeerInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LoginResponse.peer_info)
  return union_.peer_info_;
}

// bytes token = 3;
inline void LoginResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:LoginResponse.token)
  return token_.GetNoArena();
}
inline void LoginResponse::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginResponse.token)
}
#if LANG_CXX11
inline void LoginResponse::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginResponse.token)
}
#endif
inline void LoginResponse::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginResponse.token)
}
inline void LoginResponse::set_token(const void* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginResponse.token)
}
inline ::std::string* LoginResponse::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:LoginResponse.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse::release_token() {
  // @@protoc_insertion_point(field_release:LoginResponse.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_token(::std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:LoginResponse.token)
}

inline bool LoginResponse::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void LoginResponse::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline LoginResponse::UnionCase LoginResponse::union_case() const {
  return LoginResponse::UnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ChatMessage

// string text = 1;
inline void ChatMessage::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChatMessage::text() const {
  // @@protoc_insertion_point(field_get:ChatMessage.text)
  return text_.GetNoArena();
}
inline void ChatMessage::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChatMessage.text)
}
#if LANG_CXX11
inline void ChatMessage::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChatMessage.text)
}
#endif
inline void ChatMessage::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChatMessage.text)
}
inline void ChatMessage::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChatMessage.text)
}
inline ::std::string* ChatMessage::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:ChatMessage.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatMessage::release_text() {
  // @@protoc_insertion_point(field_release:ChatMessage.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_allocated_text(::std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ChatMessage.text)
}

// -------------------------------------------------------------------

// PeerInfo

// string username = 1;
inline void PeerInfo::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerInfo::username() const {
  // @@protoc_insertion_point(field_get:PeerInfo.username)
  return username_.GetNoArena();
}
inline void PeerInfo::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PeerInfo.username)
}
#if LANG_CXX11
inline void PeerInfo::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PeerInfo.username)
}
#endif
inline void PeerInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PeerInfo.username)
}
inline void PeerInfo::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PeerInfo.username)
}
inline ::std::string* PeerInfo::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:PeerInfo.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerInfo::release_username() {
  // @@protoc_insertion_point(field_release:PeerInfo.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerInfo::set_allocated_username(::std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:PeerInfo.username)
}

// string hostname = 2;
inline void PeerInfo::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerInfo::hostname() const {
  // @@protoc_insertion_point(field_get:PeerInfo.hostname)
  return hostname_.GetNoArena();
}
inline void PeerInfo::set_hostname(const ::std::string& value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PeerInfo.hostname)
}
#if LANG_CXX11
inline void PeerInfo::set_hostname(::std::string&& value) {
  
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PeerInfo.hostname)
}
#endif
inline void PeerInfo::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PeerInfo.hostname)
}
inline void PeerInfo::set_hostname(const char* value, size_t size) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PeerInfo.hostname)
}
inline ::std::string* PeerInfo::mutable_hostname() {
  
  // @@protoc_insertion_point(field_mutable:PeerInfo.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:PeerInfo.hostname)
  
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:PeerInfo.hostname)
}

// string platform = 3;
inline void PeerInfo::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerInfo::platform() const {
  // @@protoc_insertion_point(field_get:PeerInfo.platform)
  return platform_.GetNoArena();
}
inline void PeerInfo::set_platform(const ::std::string& value) {
  
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PeerInfo.platform)
}
#if LANG_CXX11
inline void PeerInfo::set_platform(::std::string&& value) {
  
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PeerInfo.platform)
}
#endif
inline void PeerInfo::set_platform(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PeerInfo.platform)
}
inline void PeerInfo::set_platform(const char* value, size_t size) {
  
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PeerInfo.platform)
}
inline ::std::string* PeerInfo::mutable_platform() {
  
  // @@protoc_insertion_point(field_mutable:PeerInfo.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerInfo::release_platform() {
  // @@protoc_insertion_point(field_release:PeerInfo.platform)
  
  return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerInfo::set_allocated_platform(::std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:PeerInfo.platform)
}

// string version = 4;
inline void PeerInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerInfo::version() const {
  // @@protoc_insertion_point(field_get:PeerInfo.version)
  return version_.GetNoArena();
}
inline void PeerInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PeerInfo.version)
}
#if LANG_CXX11
inline void PeerInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PeerInfo.version)
}
#endif
inline void PeerInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PeerInfo.version)
}
inline void PeerInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PeerInfo.version)
}
inline ::std::string* PeerInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:PeerInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerInfo::release_version() {
  // @@protoc_insertion_point(field_release:PeerInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerInfo::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:PeerInfo.version)
}

// bool privacy_mode = 5;
inline void PeerInfo::clear_privacy_mode() {
  privacy_mode_ = false;
}
inline bool PeerInfo::privacy_mode() const {
  // @@protoc_insertion_point(field_get:PeerInfo.privacy_mode)
  return privacy_mode_;
}
inline void PeerInfo::set_privacy_mode(bool value) {
  
  privacy_mode_ = value;
  // @@protoc_insertion_point(field_set:PeerInfo.privacy_mode)
}

// -------------------------------------------------------------------

// PermissionInfo

// .PermissionInfo.Permission permission = 1;
inline void PermissionInfo::clear_permission() {
  permission_ = 0;
}
inline ::PermissionInfo_Permission PermissionInfo::permission() const {
  // @@protoc_insertion_point(field_get:PermissionInfo.permission)
  return static_cast< ::PermissionInfo_Permission >(permission_);
}
inline void PermissionInfo::set_permission(::PermissionInfo_Permission value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:PermissionInfo.permission)
}

// bool enabled = 2;
inline void PermissionInfo::clear_enabled() {
  enabled_ = false;
}
inline bool PermissionInfo::enabled() const {
  // @@protoc_insertion_point(field_get:PermissionInfo.enabled)
  return enabled_;
}
inline void PermissionInfo::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:PermissionInfo.enabled)
}

// -------------------------------------------------------------------

// OptionMessage

// .OptionMessage.BoolOption lock_after_session_end = 2;
inline void OptionMessage::clear_lock_after_session_end() {
  lock_after_session_end_ = 0;
}
inline ::OptionMessage_BoolOption OptionMessage::lock_after_session_end() const {
  // @@protoc_insertion_point(field_get:OptionMessage.lock_after_session_end)
  return static_cast< ::OptionMessage_BoolOption >(lock_after_session_end_);
}
inline void OptionMessage::set_lock_after_session_end(::OptionMessage_BoolOption value) {
  
  lock_after_session_end_ = value;
  // @@protoc_insertion_point(field_set:OptionMessage.lock_after_session_end)
}

// .OptionMessage.BoolOption show_remote_cursor = 3;
inline void OptionMessage::clear_show_remote_cursor() {
  show_remote_cursor_ = 0;
}
inline ::OptionMessage_BoolOption OptionMessage::show_remote_cursor() const {
  // @@protoc_insertion_point(field_get:OptionMessage.show_remote_cursor)
  return static_cast< ::OptionMessage_BoolOption >(show_remote_cursor_);
}
inline void OptionMessage::set_show_remote_cursor(::OptionMessage_BoolOption value) {
  
  show_remote_cursor_ = value;
  // @@protoc_insertion_point(field_set:OptionMessage.show_remote_cursor)
}

// .OptionMessage.BoolOption privacy_mode = 4;
inline void OptionMessage::clear_privacy_mode() {
  privacy_mode_ = 0;
}
inline ::OptionMessage_BoolOption OptionMessage::privacy_mode() const {
  // @@protoc_insertion_point(field_get:OptionMessage.privacy_mode)
  return static_cast< ::OptionMessage_BoolOption >(privacy_mode_);
}
inline void OptionMessage::set_privacy_mode(::OptionMessage_BoolOption value) {
  
  privacy_mode_ = value;
  // @@protoc_insertion_point(field_set:OptionMessage.privacy_mode)
}

// .OptionMessage.BoolOption block_input = 5;
inline void OptionMessage::clear_block_input() {
  block_input_ = 0;
}
inline ::OptionMessage_BoolOption OptionMessage::block_input() const {
  // @@protoc_insertion_point(field_get:OptionMessage.block_input)
  return static_cast< ::OptionMessage_BoolOption >(block_input_);
}
inline void OptionMessage::set_block_input(::OptionMessage_BoolOption value) {
  
  block_input_ = value;
  // @@protoc_insertion_point(field_set:OptionMessage.block_input)
}

// .OptionMessage.BoolOption disable_clipboard = 6;
inline void OptionMessage::clear_disable_clipboard() {
  disable_clipboard_ = 0;
}
inline ::OptionMessage_BoolOption OptionMessage::disable_clipboard() const {
  // @@protoc_insertion_point(field_get:OptionMessage.disable_clipboard)
  return static_cast< ::OptionMessage_BoolOption >(disable_clipboard_);
}
inline void OptionMessage::set_disable_clipboard(::OptionMessage_BoolOption value) {
  
  disable_clipboard_ = value;
  // @@protoc_insertion_point(field_set:OptionMessage.disable_clipboard)
}

// .OptionMessage.BoolOption enable_file_transfer = 7;
inline void OptionMessage::clear_enable_file_transfer() {
  enable_file_transfer_ = 0;
}
inline ::OptionMessage_BoolOption OptionMessage::enable_file_transfer() const {
  // @@protoc_insertion_point(field_get:OptionMessage.enable_file_transfer)
  return static_cast< ::OptionMessage_BoolOption >(enable_file_transfer_);
}
inline void OptionMessage::set_enable_file_transfer(::OptionMessage_BoolOption value) {
  
  enable_file_transfer_ = value;
  // @@protoc_insertion_point(field_set:OptionMessage.enable_file_transfer)
}

// .OptionMessage.BoolOption disable_keyboard = 8;
inline void OptionMessage::clear_disable_keyboard() {
  disable_keyboard_ = 0;
}
inline ::OptionMessage_BoolOption OptionMessage::disable_keyboard() const {
  // @@protoc_insertion_point(field_get:OptionMessage.disable_keyboard)
  return static_cast< ::OptionMessage_BoolOption >(disable_keyboard_);
}
inline void OptionMessage::set_disable_keyboard(::OptionMessage_BoolOption value) {
  
  disable_keyboard_ = value;
  // @@protoc_insertion_point(field_set:OptionMessage.disable_keyboard)
}

// -------------------------------------------------------------------

// FileEntry

// .FileType type = 1;
inline void FileEntry::clear_type() {
  type_ = 0;
}
inline ::FileType FileEntry::type() const {
  // @@protoc_insertion_point(field_get:FileEntry.type)
  return static_cast< ::FileType >(type_);
}
inline void FileEntry::set_type(::FileType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:FileEntry.type)
}

// string name = 2;
inline void FileEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileEntry::name() const {
  // @@protoc_insertion_point(field_get:FileEntry.name)
  return name_.GetNoArena();
}
inline void FileEntry::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEntry.name)
}
#if LANG_CXX11
inline void FileEntry::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileEntry.name)
}
#endif
inline void FileEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEntry.name)
}
inline void FileEntry::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEntry.name)
}
inline ::std::string* FileEntry::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:FileEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileEntry::release_name() {
  // @@protoc_insertion_point(field_release:FileEntry.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEntry::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:FileEntry.name)
}

// bool hidden = 3;
inline void FileEntry::clear_hidden() {
  hidden_ = false;
}
inline bool FileEntry::hidden() const {
  // @@protoc_insertion_point(field_get:FileEntry.hidden)
  return hidden_;
}
inline void FileEntry::set_hidden(bool value) {
  
  hidden_ = value;
  // @@protoc_insertion_point(field_set:FileEntry.hidden)
}

// int64 size = 4;
inline void FileEntry::clear_size() {
  size_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 FileEntry::size() const {
  // @@protoc_insertion_point(field_get:FileEntry.size)
  return size_;
}
inline void FileEntry::set_size(::google::protobuf::int64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:FileEntry.size)
}

// int64 modified_time = 5;
inline void FileEntry::clear_modified_time() {
  modified_time_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 FileEntry::modified_time() const {
  // @@protoc_insertion_point(field_get:FileEntry.modified_time)
  return modified_time_;
}
inline void FileEntry::set_modified_time(::google::protobuf::int64 value) {
  
  modified_time_ = value;
  // @@protoc_insertion_point(field_set:FileEntry.modified_time)
}

// -------------------------------------------------------------------

// FileDirectory

// int32 id = 1;
inline void FileDirectory::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileDirectory::id() const {
  // @@protoc_insertion_point(field_get:FileDirectory.id)
  return id_;
}
inline void FileDirectory::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileDirectory.id)
}

// string path = 2;
inline void FileDirectory::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileDirectory::path() const {
  // @@protoc_insertion_point(field_get:FileDirectory.path)
  return path_.GetNoArena();
}
inline void FileDirectory::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileDirectory.path)
}
#if LANG_CXX11
inline void FileDirectory::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileDirectory.path)
}
#endif
inline void FileDirectory::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileDirectory.path)
}
inline void FileDirectory::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileDirectory.path)
}
inline ::std::string* FileDirectory::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileDirectory.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileDirectory::release_path() {
  // @@protoc_insertion_point(field_release:FileDirectory.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDirectory::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileDirectory.path)
}

// repeated .FileEntry entries = 3;
inline int FileDirectory::entries_size() const {
  return entries_.size();
}
inline void FileDirectory::clear_entries() {
  entries_.Clear();
}
inline ::FileEntry* FileDirectory::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:FileDirectory.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::FileEntry >*
FileDirectory::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:FileDirectory.entries)
  return &entries_;
}
inline const ::FileEntry& FileDirectory::entries(int index) const {
  // @@protoc_insertion_point(field_get:FileDirectory.entries)
  return entries_.Get(index);
}
inline ::FileEntry* FileDirectory::add_entries() {
  // @@protoc_insertion_point(field_add:FileDirectory.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileEntry >&
FileDirectory::entries() const {
  // @@protoc_insertion_point(field_list:FileDirectory.entries)
  return entries_;
}

// -------------------------------------------------------------------

// ReadDirFiles

// int32 id = 1;
inline void ReadDirFiles::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ReadDirFiles::id() const {
  // @@protoc_insertion_point(field_get:ReadDirFiles.id)
  return id_;
}
inline void ReadDirFiles::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:ReadDirFiles.id)
}

// string path = 2;
inline void ReadDirFiles::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadDirFiles::path() const {
  // @@protoc_insertion_point(field_get:ReadDirFiles.path)
  return path_.GetNoArena();
}
inline void ReadDirFiles::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ReadDirFiles.path)
}
#if LANG_CXX11
inline void ReadDirFiles::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ReadDirFiles.path)
}
#endif
inline void ReadDirFiles::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ReadDirFiles.path)
}
inline void ReadDirFiles::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ReadDirFiles.path)
}
inline ::std::string* ReadDirFiles::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:ReadDirFiles.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadDirFiles::release_path() {
  // @@protoc_insertion_point(field_release:ReadDirFiles.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadDirFiles::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ReadDirFiles.path)
}

// bool include_hidden = 3;
inline void ReadDirFiles::clear_include_hidden() {
  include_hidden_ = false;
}
inline bool ReadDirFiles::include_hidden() const {
  // @@protoc_insertion_point(field_get:ReadDirFiles.include_hidden)
  return include_hidden_;
}
inline void ReadDirFiles::set_include_hidden(bool value) {
  
  include_hidden_ = value;
  // @@protoc_insertion_point(field_set:ReadDirFiles.include_hidden)
}

// bool recursive = 4;
inline void ReadDirFiles::clear_recursive() {
  recursive_ = false;
}
inline bool ReadDirFiles::recursive() const {
  // @@protoc_insertion_point(field_get:ReadDirFiles.recursive)
  return recursive_;
}
inline void ReadDirFiles::set_recursive(bool value) {
  
  recursive_ = value;
  // @@protoc_insertion_point(field_set:ReadDirFiles.recursive)
}

// -------------------------------------------------------------------

// FileRemove

// int32 id = 1;
inline void FileRemove::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileRemove::id() const {
  // @@protoc_insertion_point(field_get:FileRemove.id)
  return id_;
}
inline void FileRemove::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileRemove.id)
}

// string path = 2;
inline void FileRemove::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileRemove::path() const {
  // @@protoc_insertion_point(field_get:FileRemove.path)
  return path_.GetNoArena();
}
inline void FileRemove::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileRemove.path)
}
#if LANG_CXX11
inline void FileRemove::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileRemove.path)
}
#endif
inline void FileRemove::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileRemove.path)
}
inline void FileRemove::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileRemove.path)
}
inline ::std::string* FileRemove::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileRemove.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileRemove::release_path() {
  // @@protoc_insertion_point(field_release:FileRemove.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileRemove::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileRemove.path)
}

// bool recursive = 3;
inline bool FileRemove::has_recursive() const {
  return union_case() == kRecursive;
}
inline void FileRemove::set_has_recursive() {
  _oneof_case_[0] = kRecursive;
}
inline void FileRemove::clear_recursive() {
  if (has_recursive()) {
    union_.recursive_ = false;
    clear_has_union();
  }
}
inline bool FileRemove::recursive() const {
  // @@protoc_insertion_point(field_get:FileRemove.recursive)
  if (has_recursive()) {
    return union_.recursive_;
  }
  return false;
}
inline void FileRemove::set_recursive(bool value) {
  if (!has_recursive()) {
    clear_union();
    set_has_recursive();
  }
  union_.recursive_ = value;
  // @@protoc_insertion_point(field_set:FileRemove.recursive)
}

// uint32 file_num = 4;
inline bool FileRemove::has_file_num() const {
  return union_case() == kFileNum;
}
inline void FileRemove::set_has_file_num() {
  _oneof_case_[0] = kFileNum;
}
inline void FileRemove::clear_file_num() {
  if (has_file_num()) {
    union_.file_num_ = 0u;
    clear_has_union();
  }
}
inline ::google::protobuf::uint32 FileRemove::file_num() const {
  // @@protoc_insertion_point(field_get:FileRemove.file_num)
  if (has_file_num()) {
    return union_.file_num_;
  }
  return 0u;
}
inline void FileRemove::set_file_num(::google::protobuf::uint32 value) {
  if (!has_file_num()) {
    clear_union();
    set_has_file_num();
  }
  union_.file_num_ = value;
  // @@protoc_insertion_point(field_set:FileRemove.file_num)
}

inline bool FileRemove::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void FileRemove::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline FileRemove::UnionCase FileRemove::union_case() const {
  return FileRemove::UnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileRename

// int32 id = 1;
inline void FileRename::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileRename::id() const {
  // @@protoc_insertion_point(field_get:FileRename.id)
  return id_;
}
inline void FileRename::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileRename.id)
}

// string path = 2;
inline void FileRename::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileRename::path() const {
  // @@protoc_insertion_point(field_get:FileRename.path)
  return path_.GetNoArena();
}
inline void FileRename::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileRename.path)
}
#if LANG_CXX11
inline void FileRename::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileRename.path)
}
#endif
inline void FileRename::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileRename.path)
}
inline void FileRename::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileRename.path)
}
inline ::std::string* FileRename::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileRename.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileRename::release_path() {
  // @@protoc_insertion_point(field_release:FileRename.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileRename::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileRename.path)
}

// -------------------------------------------------------------------

// FileCreate

// int32 id = 1;
inline void FileCreate::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileCreate::id() const {
  // @@protoc_insertion_point(field_get:FileCreate.id)
  return id_;
}
inline void FileCreate::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileCreate.id)
}

// string path = 2;
inline void FileCreate::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileCreate::path() const {
  // @@protoc_insertion_point(field_get:FileCreate.path)
  return path_.GetNoArena();
}
inline void FileCreate::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileCreate.path)
}
#if LANG_CXX11
inline void FileCreate::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileCreate.path)
}
#endif
inline void FileCreate::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileCreate.path)
}
inline void FileCreate::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileCreate.path)
}
inline ::std::string* FileCreate::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileCreate.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileCreate::release_path() {
  // @@protoc_insertion_point(field_release:FileCreate.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileCreate::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileCreate.path)
}

// bool is_dir = 3;
inline void FileCreate::clear_is_dir() {
  is_dir_ = false;
}
inline bool FileCreate::is_dir() const {
  // @@protoc_insertion_point(field_get:FileCreate.is_dir)
  return is_dir_;
}
inline void FileCreate::set_is_dir(bool value) {
  
  is_dir_ = value;
  // @@protoc_insertion_point(field_set:FileCreate.is_dir)
}

// -------------------------------------------------------------------

// FileAction

// .ReadDirFiles read_files = 1;
inline bool FileAction::has_read_files() const {
  return union_case() == kReadFiles;
}
inline void FileAction::set_has_read_files() {
  _oneof_case_[0] = kReadFiles;
}
inline void FileAction::clear_read_files() {
  if (has_read_files()) {
    delete union_.read_files_;
    clear_has_union();
  }
}
inline ::ReadDirFiles* FileAction::release_read_files() {
  // @@protoc_insertion_point(field_release:FileAction.read_files)
  if (has_read_files()) {
    clear_has_union();
      ::ReadDirFiles* temp = union_.read_files_;
    union_.read_files_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ReadDirFiles& FileAction::read_files() const {
  // @@protoc_insertion_point(field_get:FileAction.read_files)
  return has_read_files()
      ? *union_.read_files_
      : *reinterpret_cast< ::ReadDirFiles*>(&::_ReadDirFiles_default_instance_);
}
inline ::ReadDirFiles* FileAction::mutable_read_files() {
  if (!has_read_files()) {
    clear_union();
    set_has_read_files();
    union_.read_files_ = CreateMaybeMessage< ::ReadDirFiles >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.read_files)
  return union_.read_files_;
}

// .FileCreate create = 2;
inline bool FileAction::has_create() const {
  return union_case() == kCreate;
}
inline void FileAction::set_has_create() {
  _oneof_case_[0] = kCreate;
}
inline void FileAction::clear_create() {
  if (has_create()) {
    delete union_.create_;
    clear_has_union();
  }
}
inline ::FileCreate* FileAction::release_create() {
  // @@protoc_insertion_point(field_release:FileAction.create)
  if (has_create()) {
    clear_has_union();
      ::FileCreate* temp = union_.create_;
    union_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileCreate& FileAction::create() const {
  // @@protoc_insertion_point(field_get:FileAction.create)
  return has_create()
      ? *union_.create_
      : *reinterpret_cast< ::FileCreate*>(&::_FileCreate_default_instance_);
}
inline ::FileCreate* FileAction::mutable_create() {
  if (!has_create()) {
    clear_union();
    set_has_create();
    union_.create_ = CreateMaybeMessage< ::FileCreate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.create)
  return union_.create_;
}

// .FileRemove remove = 3;
inline bool FileAction::has_remove() const {
  return union_case() == kRemove;
}
inline void FileAction::set_has_remove() {
  _oneof_case_[0] = kRemove;
}
inline void FileAction::clear_remove() {
  if (has_remove()) {
    delete union_.remove_;
    clear_has_union();
  }
}
inline ::FileRemove* FileAction::release_remove() {
  // @@protoc_insertion_point(field_release:FileAction.remove)
  if (has_remove()) {
    clear_has_union();
      ::FileRemove* temp = union_.remove_;
    union_.remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileRemove& FileAction::remove() const {
  // @@protoc_insertion_point(field_get:FileAction.remove)
  return has_remove()
      ? *union_.remove_
      : *reinterpret_cast< ::FileRemove*>(&::_FileRemove_default_instance_);
}
inline ::FileRemove* FileAction::mutable_remove() {
  if (!has_remove()) {
    clear_union();
    set_has_remove();
    union_.remove_ = CreateMaybeMessage< ::FileRemove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.remove)
  return union_.remove_;
}

// .FileRename rename = 4;
inline bool FileAction::has_rename() const {
  return union_case() == kRename;
}
inline void FileAction::set_has_rename() {
  _oneof_case_[0] = kRename;
}
inline void FileAction::clear_rename() {
  if (has_rename()) {
    delete union_.rename_;
    clear_has_union();
  }
}
inline ::FileRename* FileAction::release_rename() {
  // @@protoc_insertion_point(field_release:FileAction.rename)
  if (has_rename()) {
    clear_has_union();
      ::FileRename* temp = union_.rename_;
    union_.rename_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileRename& FileAction::rename() const {
  // @@protoc_insertion_point(field_get:FileAction.rename)
  return has_rename()
      ? *union_.rename_
      : *reinterpret_cast< ::FileRename*>(&::_FileRename_default_instance_);
}
inline ::FileRename* FileAction::mutable_rename() {
  if (!has_rename()) {
    clear_union();
    set_has_rename();
    union_.rename_ = CreateMaybeMessage< ::FileRename >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.rename)
  return union_.rename_;
}

// .FileTransferRequest transfer = 5;
inline bool FileAction::has_transfer() const {
  return union_case() == kTransfer;
}
inline void FileAction::set_has_transfer() {
  _oneof_case_[0] = kTransfer;
}
inline void FileAction::clear_transfer() {
  if (has_transfer()) {
    delete union_.transfer_;
    clear_has_union();
  }
}
inline ::FileTransferRequest* FileAction::release_transfer() {
  // @@protoc_insertion_point(field_release:FileAction.transfer)
  if (has_transfer()) {
    clear_has_union();
      ::FileTransferRequest* temp = union_.transfer_;
    union_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransferRequest& FileAction::transfer() const {
  // @@protoc_insertion_point(field_get:FileAction.transfer)
  return has_transfer()
      ? *union_.transfer_
      : *reinterpret_cast< ::FileTransferRequest*>(&::_FileTransferRequest_default_instance_);
}
inline ::FileTransferRequest* FileAction::mutable_transfer() {
  if (!has_transfer()) {
    clear_union();
    set_has_transfer();
    union_.transfer_ = CreateMaybeMessage< ::FileTransferRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.transfer)
  return union_.transfer_;
}

// .FileTransferCancel cancel = 6;
inline bool FileAction::has_cancel() const {
  return union_case() == kCancel;
}
inline void FileAction::set_has_cancel() {
  _oneof_case_[0] = kCancel;
}
inline void FileAction::clear_cancel() {
  if (has_cancel()) {
    delete union_.cancel_;
    clear_has_union();
  }
}
inline ::FileTransferCancel* FileAction::release_cancel() {
  // @@protoc_insertion_point(field_release:FileAction.cancel)
  if (has_cancel()) {
    clear_has_union();
      ::FileTransferCancel* temp = union_.cancel_;
    union_.cancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransferCancel& FileAction::cancel() const {
  // @@protoc_insertion_point(field_get:FileAction.cancel)
  return has_cancel()
      ? *union_.cancel_
      : *reinterpret_cast< ::FileTransferCancel*>(&::_FileTransferCancel_default_instance_);
}
inline ::FileTransferCancel* FileAction::mutable_cancel() {
  if (!has_cancel()) {
    clear_union();
    set_has_cancel();
    union_.cancel_ = CreateMaybeMessage< ::FileTransferCancel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.cancel)
  return union_.cancel_;
}

inline bool FileAction::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void FileAction::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline FileAction::UnionCase FileAction::union_case() const {
  return FileAction::UnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileTransferCancel

// int32 id = 1;
inline void FileTransferCancel::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileTransferCancel::id() const {
  // @@protoc_insertion_point(field_get:FileTransferCancel.id)
  return id_;
}
inline void FileTransferCancel::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileTransferCancel.id)
}

// -------------------------------------------------------------------

// FileResponse

// .FileDirectory dir = 1;
inline bool FileResponse::has_dir() const {
  return union_case() == kDir;
}
inline void FileResponse::set_has_dir() {
  _oneof_case_[0] = kDir;
}
inline void FileResponse::clear_dir() {
  if (has_dir()) {
    delete union_.dir_;
    clear_has_union();
  }
}
inline ::FileDirectory* FileResponse::release_dir() {
  // @@protoc_insertion_point(field_release:FileResponse.dir)
  if (has_dir()) {
    clear_has_union();
      ::FileDirectory* temp = union_.dir_;
    union_.dir_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileDirectory& FileResponse::dir() const {
  // @@protoc_insertion_point(field_get:FileResponse.dir)
  return has_dir()
      ? *union_.dir_
      : *reinterpret_cast< ::FileDirectory*>(&::_FileDirectory_default_instance_);
}
inline ::FileDirectory* FileResponse::mutable_dir() {
  if (!has_dir()) {
    clear_union();
    set_has_dir();
    union_.dir_ = CreateMaybeMessage< ::FileDirectory >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileResponse.dir)
  return union_.dir_;
}

// .FileTransferConfirm confirm = 2;
inline bool FileResponse::has_confirm() const {
  return union_case() == kConfirm;
}
inline void FileResponse::set_has_confirm() {
  _oneof_case_[0] = kConfirm;
}
inline void FileResponse::clear_confirm() {
  if (has_confirm()) {
    delete union_.confirm_;
    clear_has_union();
  }
}
inline ::FileTransferConfirm* FileResponse::release_confirm() {
  // @@protoc_insertion_point(field_release:FileResponse.confirm)
  if (has_confirm()) {
    clear_has_union();
      ::FileTransferConfirm* temp = union_.confirm_;
    union_.confirm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransferConfirm& FileResponse::confirm() const {
  // @@protoc_insertion_point(field_get:FileResponse.confirm)
  return has_confirm()
      ? *union_.confirm_
      : *reinterpret_cast< ::FileTransferConfirm*>(&::_FileTransferConfirm_default_instance_);
}
inline ::FileTransferConfirm* FileResponse::mutable_confirm() {
  if (!has_confirm()) {
    clear_union();
    set_has_confirm();
    union_.confirm_ = CreateMaybeMessage< ::FileTransferConfirm >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileResponse.confirm)
  return union_.confirm_;
}

// .FileTransferBlock block = 3;
inline bool FileResponse::has_block() const {
  return union_case() == kBlock;
}
inline void FileResponse::set_has_block() {
  _oneof_case_[0] = kBlock;
}
inline void FileResponse::clear_block() {
  if (has_block()) {
    delete union_.block_;
    clear_has_union();
  }
}
inline ::FileTransferBlock* FileResponse::release_block() {
  // @@protoc_insertion_point(field_release:FileResponse.block)
  if (has_block()) {
    clear_has_union();
      ::FileTransferBlock* temp = union_.block_;
    union_.block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransferBlock& FileResponse::block() const {
  // @@protoc_insertion_point(field_get:FileResponse.block)
  return has_block()
      ? *union_.block_
      : *reinterpret_cast< ::FileTransferBlock*>(&::_FileTransferBlock_default_instance_);
}
inline ::FileTransferBlock* FileResponse::mutable_block() {
  if (!has_block()) {
    clear_union();
    set_has_block();
    union_.block_ = CreateMaybeMessage< ::FileTransferBlock >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileResponse.block)
  return union_.block_;
}

// .FileTransferDigest digest = 4;
inline bool FileResponse::has_digest() const {
  return union_case() == kDigest;
}
inline void FileResponse::set_has_digest() {
  _oneof_case_[0] = kDigest;
}
inline void FileResponse::clear_digest() {
  if (has_digest()) {
    delete union_.digest_;
    clear_has_union();
  }
}
inline ::FileTransferDigest* FileResponse::release_digest() {
  // @@protoc_insertion_point(field_release:FileResponse.digest)
  if (has_digest()) {
    clear_has_union();
      ::FileTransferDigest* temp = union_.digest_;
    union_.digest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransferDigest& FileResponse::digest() const {
  // @@protoc_insertion_point(field_get:FileResponse.digest)
  return has_digest()
      ? *union_.digest_
      : *reinterpret_cast< ::FileTransferDigest*>(&::_FileTransferDigest_default_instance_);
}
inline ::FileTransferDigest* FileResponse::mutable_digest() {
  if (!has_digest()) {
    clear_union();
    set_has_digest();
    union_.digest_ = CreateMaybeMessage< ::FileTransferDigest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileResponse.digest)
  return union_.digest_;
}

// .FileTransferError error = 5;
inline bool FileResponse::has_error() const {
  return union_case() == kError;
}
inline void FileResponse::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void FileResponse::clear_error() {
  if (has_error()) {
    delete union_.error_;
    clear_has_union();
  }
}
inline ::FileTransferError* FileResponse::release_error() {
  // @@protoc_insertion_point(field_release:FileResponse.error)
  if (has_error()) {
    clear_has_union();
      ::FileTransferError* temp = union_.error_;
    union_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransferError& FileResponse::error() const {
  // @@protoc_insertion_point(field_get:FileResponse.error)
  return has_error()
      ? *union_.error_
      : *reinterpret_cast< ::FileTransferError*>(&::_FileTransferError_default_instance_);
}
inline ::FileTransferError* FileResponse::mutable_error() {
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_ = CreateMaybeMessage< ::FileTransferError >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileResponse.error)
  return union_.error_;
}

// .FileTransferDone done = 6;
inline bool FileResponse::has_done() const {
  return union_case() == kDone;
}
inline void FileResponse::set_has_done() {
  _oneof_case_[0] = kDone;
}
inline void FileResponse::clear_done() {
  if (has_done()) {
    delete union_.done_;
    clear_has_union();
  }
}
inline ::FileTransferDone* FileResponse::release_done() {
  // @@protoc_insertion_point(field_release:FileResponse.done)
  if (has_done()) {
    clear_has_union();
      ::FileTransferDone* temp = union_.done_;
    union_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransferDone& FileResponse::done() const {
  // @@protoc_insertion_point(field_get:FileResponse.done)
  return has_done()
      ? *union_.done_
      : *reinterpret_cast< ::FileTransferDone*>(&::_FileTransferDone_default_instance_);
}
inline ::FileTransferDone* FileResponse::mutable_done() {
  if (!has_done()) {
    clear_union();
    set_has_done();
    union_.done_ = CreateMaybeMessage< ::FileTransferDone >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileResponse.done)
  return union_.done_;
}

inline bool FileResponse::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void FileResponse::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline FileResponse::UnionCase FileResponse::union_case() const {
  return FileResponse::UnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileTransferConfirm

// int32 id = 1;
inline void FileTransferConfirm::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileTransferConfirm::id() const {
  // @@protoc_insertion_point(field_get:FileTransferConfirm.id)
  return id_;
}
inline void FileTransferConfirm::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileTransferConfirm.id)
}

// string path = 2;
inline void FileTransferConfirm::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransferConfirm::path() const {
  // @@protoc_insertion_point(field_get:FileTransferConfirm.path)
  return path_.GetNoArena();
}
inline void FileTransferConfirm::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransferConfirm.path)
}
#if LANG_CXX11
inline void FileTransferConfirm::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransferConfirm.path)
}
#endif
inline void FileTransferConfirm::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransferConfirm.path)
}
inline void FileTransferConfirm::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransferConfirm.path)
}
inline ::std::string* FileTransferConfirm::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileTransferConfirm.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransferConfirm::release_path() {
  // @@protoc_insertion_point(field_release:FileTransferConfirm.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransferConfirm::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileTransferConfirm.path)
}

// -------------------------------------------------------------------

// FileTransferBlock

// int32 id = 1;
inline void FileTransferBlock::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileTransferBlock::id() const {
  // @@protoc_insertion_point(field_get:FileTransferBlock.id)
  return id_;
}
inline void FileTransferBlock::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileTransferBlock.id)
}

// uint32 file_num = 2;
inline void FileTransferBlock::clear_file_num() {
  file_num_ = 0u;
}
inline ::google::protobuf::uint32 FileTransferBlock::file_num() const {
  // @@protoc_insertion_point(field_get:FileTransferBlock.file_num)
  return file_num_;
}
inline void FileTransferBlock::set_file_num(::google::protobuf::uint32 value) {
  
  file_num_ = value;
  // @@protoc_insertion_point(field_set:FileTransferBlock.file_num)
}

// bytes data = 3;
inline void FileTransferBlock::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransferBlock::data() const {
  // @@protoc_insertion_point(field_get:FileTransferBlock.data)
  return data_.GetNoArena();
}
inline void FileTransferBlock::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransferBlock.data)
}
#if LANG_CXX11
inline void FileTransferBlock::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransferBlock.data)
}
#endif
inline void FileTransferBlock::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransferBlock.data)
}
inline void FileTransferBlock::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransferBlock.data)
}
inline ::std::string* FileTransferBlock::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:FileTransferBlock.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransferBlock::release_data() {
  // @@protoc_insertion_point(field_release:FileTransferBlock.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransferBlock::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:FileTransferBlock.data)
}

// bool compressed = 4;
inline void FileTransferBlock::clear_compressed() {
  compressed_ = false;
}
inline bool FileTransferBlock::compressed() const {
  // @@protoc_insertion_point(field_get:FileTransferBlock.compressed)
  return compressed_;
}
inline void FileTransferBlock::set_compressed(bool value) {
  
  compressed_ = value;
  // @@protoc_insertion_point(field_set:FileTransferBlock.compressed)
}

// uint32 blk_id = 5;
inline void FileTransferBlock::clear_blk_id() {
  blk_id_ = 0u;
}
inline ::google::protobuf::uint32 FileTransferBlock::blk_id() const {
  // @@protoc_insertion_point(field_get:FileTransferBlock.blk_id)
  return blk_id_;
}
inline void FileTransferBlock::set_blk_id(::google::protobuf::uint32 value) {
  
  blk_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransferBlock.blk_id)
}

// -------------------------------------------------------------------

// FileTransferDigest

// int32 id = 1;
inline void FileTransferDigest::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileTransferDigest::id() const {
  // @@protoc_insertion_point(field_get:FileTransferDigest.id)
  return id_;
}
inline void FileTransferDigest::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileTransferDigest.id)
}

// uint32 blk_id = 2;
inline void FileTransferDigest::clear_blk_id() {
  blk_id_ = 0u;
}
inline ::google::protobuf::uint32 FileTransferDigest::blk_id() const {
  // @@protoc_insertion_point(field_get:FileTransferDigest.blk_id)
  return blk_id_;
}
inline void FileTransferDigest::set_blk_id(::google::protobuf::uint32 value) {
  
  blk_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransferDigest.blk_id)
}

// string blk_md5 = 3;
inline void FileTransferDigest::clear_blk_md5() {
  blk_md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransferDigest::blk_md5() const {
  // @@protoc_insertion_point(field_get:FileTransferDigest.blk_md5)
  return blk_md5_.GetNoArena();
}
inline void FileTransferDigest::set_blk_md5(const ::std::string& value) {
  
  blk_md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransferDigest.blk_md5)
}
#if LANG_CXX11
inline void FileTransferDigest::set_blk_md5(::std::string&& value) {
  
  blk_md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransferDigest.blk_md5)
}
#endif
inline void FileTransferDigest::set_blk_md5(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  blk_md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransferDigest.blk_md5)
}
inline void FileTransferDigest::set_blk_md5(const char* value, size_t size) {
  
  blk_md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransferDigest.blk_md5)
}
inline ::std::string* FileTransferDigest::mutable_blk_md5() {
  
  // @@protoc_insertion_point(field_mutable:FileTransferDigest.blk_md5)
  return blk_md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransferDigest::release_blk_md5() {
  // @@protoc_insertion_point(field_release:FileTransferDigest.blk_md5)
  
  return blk_md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransferDigest::set_allocated_blk_md5(::std::string* blk_md5) {
  if (blk_md5 != nullptr) {
    
  } else {
    
  }
  blk_md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blk_md5);
  // @@protoc_insertion_point(field_set_allocated:FileTransferDigest.blk_md5)
}

// -------------------------------------------------------------------

// FileTransferError

// int32 id = 1;
inline void FileTransferError::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileTransferError::id() const {
  // @@protoc_insertion_point(field_get:FileTransferError.id)
  return id_;
}
inline void FileTransferError::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileTransferError.id)
}

// string error = 2;
inline void FileTransferError::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransferError::error() const {
  // @@protoc_insertion_point(field_get:FileTransferError.error)
  return error_.GetNoArena();
}
inline void FileTransferError::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransferError.error)
}
#if LANG_CXX11
inline void FileTransferError::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransferError.error)
}
#endif
inline void FileTransferError::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransferError.error)
}
inline void FileTransferError::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransferError.error)
}
inline ::std::string* FileTransferError::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:FileTransferError.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransferError::release_error() {
  // @@protoc_insertion_point(field_release:FileTransferError.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransferError::set_allocated_error(::std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:FileTransferError.error)
}

// uint32 file_num = 3;
inline void FileTransferError::clear_file_num() {
  file_num_ = 0u;
}
inline ::google::protobuf::uint32 FileTransferError::file_num() const {
  // @@protoc_insertion_point(field_get:FileTransferError.file_num)
  return file_num_;
}
inline void FileTransferError::set_file_num(::google::protobuf::uint32 value) {
  
  file_num_ = value;
  // @@protoc_insertion_point(field_set:FileTransferError.file_num)
}

// -------------------------------------------------------------------

// FileTransferDone

// int32 id = 1;
inline void FileTransferDone::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileTransferDone::id() const {
  // @@protoc_insertion_point(field_get:FileTransferDone.id)
  return id_;
}
inline void FileTransferDone::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileTransferDone.id)
}

// uint32 file_num = 2;
inline void FileTransferDone::clear_file_num() {
  file_num_ = 0u;
}
inline ::google::protobuf::uint32 FileTransferDone::file_num() const {
  // @@protoc_insertion_point(field_get:FileTransferDone.file_num)
  return file_num_;
}
inline void FileTransferDone::set_file_num(::google::protobuf::uint32 value) {
  
  file_num_ = value;
  // @@protoc_insertion_point(field_set:FileTransferDone.file_num)
}

// -------------------------------------------------------------------

// FileTransferRequest

// int32 id = 1;
inline void FileTransferRequest::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileTransferRequest::id() const {
  // @@protoc_insertion_point(field_get:FileTransferRequest.id)
  return id_;
}
inline void FileTransferRequest::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileTransferRequest.id)
}

// string path = 2;
inline void FileTransferRequest::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransferRequest::path() const {
  // @@protoc_insertion_point(field_get:FileTransferRequest.path)
  return path_.GetNoArena();
}
inline void FileTransferRequest::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransferRequest.path)
}
#if LANG_CXX11
inline void FileTransferRequest::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransferRequest.path)
}
#endif
inline void FileTransferRequest::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransferRequest.path)
}
inline void FileTransferRequest::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransferRequest.path)
}
inline ::std::string* FileTransferRequest::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileTransferRequest.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransferRequest::release_path() {
  // @@protoc_insertion_point(field_release:FileTransferRequest.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransferRequest::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileTransferRequest.path)
}

// uint32 file_num = 3;
inline void FileTransferRequest::clear_file_num() {
  file_num_ = 0u;
}
inline ::google::protobuf::uint32 FileTransferRequest::file_num() const {
  // @@protoc_insertion_point(field_get:FileTransferRequest.file_num)
  return file_num_;
}
inline void FileTransferRequest::set_file_num(::google::protobuf::uint32 value) {
  
  file_num_ = value;
  // @@protoc_insertion_point(field_set:FileTransferRequest.file_num)
}

// bool include_hidden = 4;
inline void FileTransferRequest::clear_include_hidden() {
  include_hidden_ = false;
}
inline bool FileTransferRequest::include_hidden() const {
  // @@protoc_insertion_point(field_get:FileTransferRequest.include_hidden)
  return include_hidden_;
}
inline void FileTransferRequest::set_include_hidden(bool value) {
  
  include_hidden_ = value;
  // @@protoc_insertion_point(field_set:FileTransferRequest.include_hidden)
}

// .FileTransferRequest.Direction ask = 5;
inline void FileTransferRequest::clear_ask() {
  ask_ = 0;
}
inline ::FileTransferRequest_Direction FileTransferRequest::ask() const {
  // @@protoc_insertion_point(field_get:FileTransferRequest.ask)
  return static_cast< ::FileTransferRequest_Direction >(ask_);
}
inline void FileTransferRequest::set_ask(::FileTransferRequest_Direction value) {
  
  ask_ = value;
  // @@protoc_insertion_point(field_set:FileTransferRequest.ask)
}

// -------------------------------------------------------------------

// FileTransResponse

// int32 id = 1;
inline void FileTransResponse::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileTransResponse::id() const {
  // @@protoc_insertion_point(field_get:FileTransResponse.id)
  return id_;
}
inline void FileTransResponse::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileTransResponse.id)
}

// string name = 2;
inline void FileTransResponse::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransResponse::name() const {
  // @@protoc_insertion_point(field_get:FileTransResponse.name)
  return name_.GetNoArena();
}
inline void FileTransResponse::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransResponse.name)
}
#if LANG_CXX11
inline void FileTransResponse::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransResponse.name)
}
#endif
inline void FileTransResponse::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransResponse.name)
}
inline void FileTransResponse::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransResponse.name)
}
inline ::std::string* FileTransResponse::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:FileTransResponse.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransResponse::release_name() {
  // @@protoc_insertion_point(field_release:FileTransResponse.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransResponse::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:FileTransResponse.name)
}

// .FileTransRe result = 3;
inline void FileTransResponse::clear_result() {
  result_ = 0;
}
inline ::FileTransRe FileTransResponse::result() const {
  // @@protoc_insertion_point(field_get:FileTransResponse.result)
  return static_cast< ::FileTransRe >(result_);
}
inline void FileTransResponse::set_result(::FileTransRe value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:FileTransResponse.result)
}

// -------------------------------------------------------------------

// FileTransJob

// int32 job_id = 1;
inline void FileTransJob::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransJob::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransJob.job_id)
  return job_id_;
}
inline void FileTransJob::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransJob.job_id)
}

// string path = 2;
inline void FileTransJob::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJob::path() const {
  // @@protoc_insertion_point(field_get:FileTransJob.path)
  return path_.GetNoArena();
}
inline void FileTransJob::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJob.path)
}
#if LANG_CXX11
inline void FileTransJob::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJob.path)
}
#endif
inline void FileTransJob::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJob.path)
}
inline void FileTransJob::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJob.path)
}
inline ::std::string* FileTransJob::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJob.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJob::release_path() {
  // @@protoc_insertion_point(field_release:FileTransJob.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJob::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileTransJob.path)
}

// bool include_hidden = 3;
inline void FileTransJob::clear_include_hidden() {
  include_hidden_ = false;
}
inline bool FileTransJob::include_hidden() const {
  // @@protoc_insertion_point(field_get:FileTransJob.include_hidden)
  return include_hidden_;
}
inline void FileTransJob::set_include_hidden(bool value) {
  
  include_hidden_ = value;
  // @@protoc_insertion_point(field_set:FileTransJob.include_hidden)
}

// bool recursive = 4;
inline void FileTransJob::clear_recursive() {
  recursive_ = false;
}
inline bool FileTransJob::recursive() const {
  // @@protoc_insertion_point(field_get:FileTransJob.recursive)
  return recursive_;
}
inline void FileTransJob::set_recursive(bool value) {
  
  recursive_ = value;
  // @@protoc_insertion_point(field_set:FileTransJob.recursive)
}

// bool push = 5;
inline void FileTransJob::clear_push() {
  push_ = false;
}
inline bool FileTransJob::push() const {
  // @@protoc_insertion_point(field_get:FileTransJob.push)
  return push_;
}
inline void FileTransJob::set_push(bool value) {
  
  push_ = value;
  // @@protoc_insertion_point(field_set:FileTransJob.push)
}

// string app_who = 6;
inline void FileTransJob::clear_app_who() {
  app_who_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJob::app_who() const {
  // @@protoc_insertion_point(field_get:FileTransJob.app_who)
  return app_who_.GetNoArena();
}
inline void FileTransJob::set_app_who(const ::std::string& value) {
  
  app_who_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJob.app_who)
}
#if LANG_CXX11
inline void FileTransJob::set_app_who(::std::string&& value) {
  
  app_who_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJob.app_who)
}
#endif
inline void FileTransJob::set_app_who(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  app_who_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJob.app_who)
}
inline void FileTransJob::set_app_who(const char* value, size_t size) {
  
  app_who_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJob.app_who)
}
inline ::std::string* FileTransJob::mutable_app_who() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJob.app_who)
  return app_who_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJob::release_app_who() {
  // @@protoc_insertion_point(field_release:FileTransJob.app_who)
  
  return app_who_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJob::set_allocated_app_who(::std::string* app_who) {
  if (app_who != nullptr) {
    
  } else {
    
  }
  app_who_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_who);
  // @@protoc_insertion_point(field_set_allocated:FileTransJob.app_who)
}

// -------------------------------------------------------------------

// FileTransCreate

// int32 job_id = 1;
inline void FileTransCreate::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransCreate::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransCreate.job_id)
  return job_id_;
}
inline void FileTransCreate::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransCreate.job_id)
}

// int32 file_id = 2;
inline void FileTransCreate::clear_file_id() {
  file_id_ = 0;
}
inline ::google::protobuf::int32 FileTransCreate::file_id() const {
  // @@protoc_insertion_point(field_get:FileTransCreate.file_id)
  return file_id_;
}
inline void FileTransCreate::set_file_id(::google::protobuf::int32 value) {
  
  file_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransCreate.file_id)
}

// string sub_dir = 3;
inline void FileTransCreate::clear_sub_dir() {
  sub_dir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransCreate::sub_dir() const {
  // @@protoc_insertion_point(field_get:FileTransCreate.sub_dir)
  return sub_dir_.GetNoArena();
}
inline void FileTransCreate::set_sub_dir(const ::std::string& value) {
  
  sub_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransCreate.sub_dir)
}
#if LANG_CXX11
inline void FileTransCreate::set_sub_dir(::std::string&& value) {
  
  sub_dir_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransCreate.sub_dir)
}
#endif
inline void FileTransCreate::set_sub_dir(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sub_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransCreate.sub_dir)
}
inline void FileTransCreate::set_sub_dir(const char* value, size_t size) {
  
  sub_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransCreate.sub_dir)
}
inline ::std::string* FileTransCreate::mutable_sub_dir() {
  
  // @@protoc_insertion_point(field_mutable:FileTransCreate.sub_dir)
  return sub_dir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransCreate::release_sub_dir() {
  // @@protoc_insertion_point(field_release:FileTransCreate.sub_dir)
  
  return sub_dir_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransCreate::set_allocated_sub_dir(::std::string* sub_dir) {
  if (sub_dir != nullptr) {
    
  } else {
    
  }
  sub_dir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sub_dir);
  // @@protoc_insertion_point(field_set_allocated:FileTransCreate.sub_dir)
}

// .FileEntry entry = 4;
inline bool FileTransCreate::has_entry() const {
  return this != internal_default_instance() && entry_ != nullptr;
}
inline void FileTransCreate::clear_entry() {
  if (GetArenaNoVirtual() == nullptr && entry_ != nullptr) {
    delete entry_;
  }
  entry_ = nullptr;
}
inline const ::FileEntry& FileTransCreate::entry() const {
  const ::FileEntry* p = entry_;
  // @@protoc_insertion_point(field_get:FileTransCreate.entry)
  return p != nullptr ? *p : *reinterpret_cast<const ::FileEntry*>(
      &::_FileEntry_default_instance_);
}
inline ::FileEntry* FileTransCreate::release_entry() {
  // @@protoc_insertion_point(field_release:FileTransCreate.entry)
  
  ::FileEntry* temp = entry_;
  entry_ = nullptr;
  return temp;
}
inline ::FileEntry* FileTransCreate::mutable_entry() {
  
  if (entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::FileEntry>(GetArenaNoVirtual());
    entry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:FileTransCreate.entry)
  return entry_;
}
inline void FileTransCreate::set_allocated_entry(::FileEntry* entry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete entry_;
  }
  if (entry) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    
  } else {
    
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:FileTransCreate.entry)
}

// -------------------------------------------------------------------

// FileTransBlock

// int32 job_id = 1;
inline void FileTransBlock::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransBlock::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.job_id)
  return job_id_;
}
inline void FileTransBlock::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransBlock.job_id)
}

// int32 file_id = 2;
inline void FileTransBlock::clear_file_id() {
  file_id_ = 0;
}
inline ::google::protobuf::int32 FileTransBlock::file_id() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.file_id)
  return file_id_;
}
inline void FileTransBlock::set_file_id(::google::protobuf::int32 value) {
  
  file_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransBlock.file_id)
}

// string filename = 3;
inline void FileTransBlock::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransBlock::filename() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.filename)
  return filename_.GetNoArena();
}
inline void FileTransBlock::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransBlock.filename)
}
#if LANG_CXX11
inline void FileTransBlock::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransBlock.filename)
}
#endif
inline void FileTransBlock::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransBlock.filename)
}
inline void FileTransBlock::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransBlock.filename)
}
inline ::std::string* FileTransBlock::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:FileTransBlock.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransBlock::release_filename() {
  // @@protoc_insertion_point(field_release:FileTransBlock.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransBlock::set_allocated_filename(::std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:FileTransBlock.filename)
}

// uint32 blk_id = 4;
inline void FileTransBlock::clear_blk_id() {
  blk_id_ = 0u;
}
inline ::google::protobuf::uint32 FileTransBlock::blk_id() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.blk_id)
  return blk_id_;
}
inline void FileTransBlock::set_blk_id(::google::protobuf::uint32 value) {
  
  blk_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransBlock.blk_id)
}

// bytes data = 5;
inline void FileTransBlock::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransBlock::data() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.data)
  return data_.GetNoArena();
}
inline void FileTransBlock::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransBlock.data)
}
#if LANG_CXX11
inline void FileTransBlock::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransBlock.data)
}
#endif
inline void FileTransBlock::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransBlock.data)
}
inline void FileTransBlock::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransBlock.data)
}
inline ::std::string* FileTransBlock::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:FileTransBlock.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransBlock::release_data() {
  // @@protoc_insertion_point(field_release:FileTransBlock.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransBlock::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:FileTransBlock.data)
}

// bool compressed = 6;
inline void FileTransBlock::clear_compressed() {
  compressed_ = false;
}
inline bool FileTransBlock::compressed() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.compressed)
  return compressed_;
}
inline void FileTransBlock::set_compressed(bool value) {
  
  compressed_ = value;
  // @@protoc_insertion_point(field_set:FileTransBlock.compressed)
}

// -------------------------------------------------------------------

// FileTransJobCancel

// int32 job_id = 1;
inline void FileTransJobCancel::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransJobCancel::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransJobCancel.job_id)
  return job_id_;
}
inline void FileTransJobCancel::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransJobCancel.job_id)
}

// string path = 2;
inline void FileTransJobCancel::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJobCancel::path() const {
  // @@protoc_insertion_point(field_get:FileTransJobCancel.path)
  return path_.GetNoArena();
}
inline void FileTransJobCancel::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJobCancel.path)
}
#if LANG_CXX11
inline void FileTransJobCancel::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJobCancel.path)
}
#endif
inline void FileTransJobCancel::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJobCancel.path)
}
inline void FileTransJobCancel::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJobCancel.path)
}
inline ::std::string* FileTransJobCancel::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJobCancel.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJobCancel::release_path() {
  // @@protoc_insertion_point(field_release:FileTransJobCancel.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJobCancel::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileTransJobCancel.path)
}

// -------------------------------------------------------------------

// FileTransJobReport

// int32 job_id = 1;
inline void FileTransJobReport::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransJobReport::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransJobReport.job_id)
  return job_id_;
}
inline void FileTransJobReport::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransJobReport.job_id)
}

// string path = 2;
inline void FileTransJobReport::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJobReport::path() const {
  // @@protoc_insertion_point(field_get:FileTransJobReport.path)
  return path_.GetNoArena();
}
inline void FileTransJobReport::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJobReport.path)
}
#if LANG_CXX11
inline void FileTransJobReport::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJobReport.path)
}
#endif
inline void FileTransJobReport::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJobReport.path)
}
inline void FileTransJobReport::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJobReport.path)
}
inline ::std::string* FileTransJobReport::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJobReport.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJobReport::release_path() {
  // @@protoc_insertion_point(field_release:FileTransJobReport.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJobReport::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileTransJobReport.path)
}

// string error = 3;
inline void FileTransJobReport::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJobReport::error() const {
  // @@protoc_insertion_point(field_get:FileTransJobReport.error)
  return error_.GetNoArena();
}
inline void FileTransJobReport::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJobReport.error)
}
#if LANG_CXX11
inline void FileTransJobReport::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJobReport.error)
}
#endif
inline void FileTransJobReport::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJobReport.error)
}
inline void FileTransJobReport::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJobReport.error)
}
inline ::std::string* FileTransJobReport::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJobReport.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJobReport::release_error() {
  // @@protoc_insertion_point(field_release:FileTransJobReport.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJobReport::set_allocated_error(::std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:FileTransJobReport.error)
}

// .FileTransRe result = 4;
inline void FileTransJobReport::clear_result() {
  result_ = 0;
}
inline ::FileTransRe FileTransJobReport::result() const {
  // @@protoc_insertion_point(field_get:FileTransJobReport.result)
  return static_cast< ::FileTransRe >(result_);
}
inline void FileTransJobReport::set_result(::FileTransRe value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:FileTransJobReport.result)
}

// -------------------------------------------------------------------

// FileTransUpdate

// .FileTransJobCancel cancel = 1;
inline bool FileTransUpdate::has_cancel() const {
  return union_case() == kCancel;
}
inline void FileTransUpdate::set_has_cancel() {
  _oneof_case_[0] = kCancel;
}
inline void FileTransUpdate::clear_cancel() {
  if (has_cancel()) {
    delete union_.cancel_;
    clear_has_union();
  }
}
inline ::FileTransJobCancel* FileTransUpdate::release_cancel() {
  // @@protoc_insertion_point(field_release:FileTransUpdate.cancel)
  if (has_cancel()) {
    clear_has_union();
      ::FileTransJobCancel* temp = union_.cancel_;
    union_.cancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransJobCancel& FileTransUpdate::cancel() const {
  // @@protoc_insertion_point(field_get:FileTransUpdate.cancel)
  return has_cancel()
      ? *union_.cancel_
      : *reinterpret_cast< ::FileTransJobCancel*>(&::_FileTransJobCancel_default_instance_);
}
inline ::FileTransJobCancel* FileTransUpdate::mutable_cancel() {
  if (!has_cancel()) {
    clear_union();
    set_has_cancel();
    union_.cancel_ = CreateMaybeMessage< ::FileTransJobCancel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileTransUpdate.cancel)
  return union_.cancel_;
}

// .FileTransJobReport report = 2;
inline bool FileTransUpdate::has_report() const {
  return union_case() == kReport;
}
inline void FileTransUpdate::set_has_report() {
  _oneof_case_[0] = kReport;
}
inline void FileTransUpdate::clear_report() {
  if (has_report()) {
    delete union_.report_;
    clear_has_union();
  }
}
inline ::FileTransJobReport* FileTransUpdate::release_report() {
  // @@protoc_insertion_point(field_release:FileTransUpdate.report)
  if (has_report()) {
    clear_has_union();
      ::FileTransJobReport* temp = union_.report_;
    union_.report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransJobReport& FileTransUpdate::report() const {
  // @@protoc_insertion_point(field_get:FileTransUpdate.report)
  return has_report()
      ? *union_.report_
      : *reinterpret_cast< ::FileTransJobReport*>(&::_FileTransJobReport_default_instance_);
}
inline ::FileTransJobReport* FileTransUpdate::mutable_report() {
  if (!has_report()) {
    clear_union();
    set_has_report();
    union_.report_ = CreateMaybeMessage< ::FileTransJobReport >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileTransUpdate.report)
  return union_.report_;
}

inline bool FileTransUpdate::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void FileTransUpdate::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline FileTransUpdate::UnionCase FileTransUpdate::union_case() const {
  return FileTransUpdate::UnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Misc

// .ChatMessage chat_message = 1;
inline bool Misc::has_chat_message() const {
  return union_case() == kChatMessage;
}
inline void Misc::set_has_chat_message() {
  _oneof_case_[0] = kChatMessage;
}
inline void Misc::clear_chat_message() {
  if (has_chat_message()) {
    delete union_.chat_message_;
    clear_has_union();
  }
}
inline ::ChatMessage* Misc::release_chat_message() {
  // @@protoc_insertion_point(field_release:Misc.chat_message)
  if (has_chat_message()) {
    clear_has_union();
      ::ChatMessage* temp = union_.chat_message_;
    union_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChatMessage& Misc::chat_message() const {
  // @@protoc_insertion_point(field_get:Misc.chat_message)
  return has_chat_message()
      ? *union_.chat_message_
      : *reinterpret_cast< ::ChatMessage*>(&::_ChatMessage_default_instance_);
}
inline ::ChatMessage* Misc::mutable_chat_message() {
  if (!has_chat_message()) {
    clear_union();
    set_has_chat_message();
    union_.chat_message_ = CreateMaybeMessage< ::ChatMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Misc.chat_message)
  return union_.chat_message_;
}

// .PermissionInfo permission_info = 2;
inline bool Misc::has_permission_info() const {
  return union_case() == kPermissionInfo;
}
inline void Misc::set_has_permission_info() {
  _oneof_case_[0] = kPermissionInfo;
}
inline void Misc::clear_permission_info() {
  if (has_permission_info()) {
    delete union_.permission_info_;
    clear_has_union();
  }
}
inline ::PermissionInfo* Misc::release_permission_info() {
  // @@protoc_insertion_point(field_release:Misc.permission_info)
  if (has_permission_info()) {
    clear_has_union();
      ::PermissionInfo* temp = union_.permission_info_;
    union_.permission_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PermissionInfo& Misc::permission_info() const {
  // @@protoc_insertion_point(field_get:Misc.permission_info)
  return has_permission_info()
      ? *union_.permission_info_
      : *reinterpret_cast< ::PermissionInfo*>(&::_PermissionInfo_default_instance_);
}
inline ::PermissionInfo* Misc::mutable_permission_info() {
  if (!has_permission_info()) {
    clear_union();
    set_has_permission_info();
    union_.permission_info_ = CreateMaybeMessage< ::PermissionInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Misc.permission_info)
  return union_.permission_info_;
}

// .OptionMessage option = 3;
inline bool Misc::has_option() const {
  return union_case() == kOption;
}
inline void Misc::set_has_option() {
  _oneof_case_[0] = kOption;
}
inline void Misc::clear_option() {
  if (has_option()) {
    delete union_.option_;
    clear_has_union();
  }
}
inline ::OptionMessage* Misc::release_option() {
  // @@protoc_insertion_point(field_release:Misc.option)
  if (has_option()) {
    clear_has_union();
      ::OptionMessage* temp = union_.option_;
    union_.option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::OptionMessage& Misc::option() const {
  // @@protoc_insertion_point(field_get:Misc.option)
  return has_option()
      ? *union_.option_
      : *reinterpret_cast< ::OptionMessage*>(&::_OptionMessage_default_instance_);
}
inline ::OptionMessage* Misc::mutable_option() {
  if (!has_option()) {
    clear_union();
    set_has_option();
    union_.option_ = CreateMaybeMessage< ::OptionMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Misc.option)
  return union_.option_;
}

// string close_reason = 4;
inline bool Misc::has_close_reason() const {
  return union_case() == kCloseReason;
}
inline void Misc::set_has_close_reason() {
  _oneof_case_[0] = kCloseReason;
}
inline void Misc::clear_close_reason() {
  if (has_close_reason()) {
    union_.close_reason_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_union();
  }
}
inline const ::std::string& Misc::close_reason() const {
  // @@protoc_insertion_point(field_get:Misc.close_reason)
  if (has_close_reason()) {
    return union_.close_reason_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Misc::set_close_reason(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Misc.close_reason)
  if (!has_close_reason()) {
    clear_union();
    set_has_close_reason();
    union_.close_reason_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.close_reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Misc.close_reason)
}
#if LANG_CXX11
inline void Misc::set_close_reason(::std::string&& value) {
  // @@protoc_insertion_point(field_set:Misc.close_reason)
  if (!has_close_reason()) {
    clear_union();
    set_has_close_reason();
    union_.close_reason_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.close_reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Misc.close_reason)
}
#endif
inline void Misc::set_close_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_close_reason()) {
    clear_union();
    set_has_close_reason();
    union_.close_reason_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.close_reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Misc.close_reason)
}
inline void Misc::set_close_reason(const char* value, size_t size) {
  if (!has_close_reason()) {
    clear_union();
    set_has_close_reason();
    union_.close_reason_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.close_reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Misc.close_reason)
}
inline ::std::string* Misc::mutable_close_reason() {
  if (!has_close_reason()) {
    clear_union();
    set_has_close_reason();
    union_.close_reason_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:Misc.close_reason)
  return union_.close_reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Misc::release_close_reason() {
  // @@protoc_insertion_point(field_release:Misc.close_reason)
  if (has_close_reason()) {
    clear_has_union();
    return union_.close_reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Misc::set_allocated_close_reason(::std::string* close_reason) {
  if (has_union()) {
    clear_union();
  }
  if (close_reason != nullptr) {
    set_has_close_reason();
    union_.close_reason_.UnsafeSetDefault(close_reason);
  }
  // @@protoc_insertion_point(field_set_allocated:Misc.close_reason)
}

// bool stop_service = 5;
inline bool Misc::has_stop_service() const {
  return union_case() == kStopService;
}
inline void Misc::set_has_stop_service() {
  _oneof_case_[0] = kStopService;
}
inline void Misc::clear_stop_service() {
  if (has_stop_service()) {
    union_.stop_service_ = false;
    clear_has_union();
  }
}
inline bool Misc::stop_service() const {
  // @@protoc_insertion_point(field_get:Misc.stop_service)
  if (has_stop_service()) {
    return union_.stop_service_;
  }
  return false;
}
inline void Misc::set_stop_service(bool value) {
  if (!has_stop_service()) {
    clear_union();
    set_has_stop_service();
  }
  union_.stop_service_ = value;
  // @@protoc_insertion_point(field_set:Misc.stop_service)
}

inline bool Misc::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void Misc::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline Misc::UnionCase Misc::union_case() const {
  return Misc::UnionCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::PermissionInfo_Permission> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PermissionInfo_Permission>() {
  return ::PermissionInfo_Permission_descriptor();
}
template <> struct is_proto_enum< ::OptionMessage_BoolOption> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OptionMessage_BoolOption>() {
  return ::OptionMessage_BoolOption_descriptor();
}
template <> struct is_proto_enum< ::FileTransferRequest_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileTransferRequest_Direction>() {
  return ::FileTransferRequest_Direction_descriptor();
}
template <> struct is_proto_enum< ::FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileType>() {
  return ::FileType_descriptor();
}
template <> struct is_proto_enum< ::FileTransRe> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileTransRe>() {
  return ::FileTransRe_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_message_2eproto
