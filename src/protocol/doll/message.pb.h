// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_INCLUDED_message_2eproto
#define PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_message_2eproto();
class ActionResult;
class ActionResultDefaultTypeInternal;
extern ActionResultDefaultTypeInternal _ActionResult_default_instance_;
class FileAction;
class FileActionDefaultTypeInternal;
extern FileActionDefaultTypeInternal _FileAction_default_instance_;
class FileCreate;
class FileCreateDefaultTypeInternal;
extern FileCreateDefaultTypeInternal _FileCreate_default_instance_;
class FileDirectory;
class FileDirectoryDefaultTypeInternal;
extern FileDirectoryDefaultTypeInternal _FileDirectory_default_instance_;
class FileEntry;
class FileEntryDefaultTypeInternal;
extern FileEntryDefaultTypeInternal _FileEntry_default_instance_;
class FileRemove;
class FileRemoveDefaultTypeInternal;
extern FileRemoveDefaultTypeInternal _FileRemove_default_instance_;
class FileRename;
class FileRenameDefaultTypeInternal;
extern FileRenameDefaultTypeInternal _FileRename_default_instance_;
class FileResponse;
class FileResponseDefaultTypeInternal;
extern FileResponseDefaultTypeInternal _FileResponse_default_instance_;
class FileTransBlock;
class FileTransBlockDefaultTypeInternal;
extern FileTransBlockDefaultTypeInternal _FileTransBlock_default_instance_;
class FileTransCreate;
class FileTransCreateDefaultTypeInternal;
extern FileTransCreateDefaultTypeInternal _FileTransCreate_default_instance_;
class FileTransJob;
class FileTransJobDefaultTypeInternal;
extern FileTransJobDefaultTypeInternal _FileTransJob_default_instance_;
class FileTransJobCancel;
class FileTransJobCancelDefaultTypeInternal;
extern FileTransJobCancelDefaultTypeInternal _FileTransJobCancel_default_instance_;
class FileTransJobReport;
class FileTransJobReportDefaultTypeInternal;
extern FileTransJobReportDefaultTypeInternal _FileTransJobReport_default_instance_;
class FileTransResponse;
class FileTransResponseDefaultTypeInternal;
extern FileTransResponseDefaultTypeInternal _FileTransResponse_default_instance_;
class FileTransUpdate;
class FileTransUpdateDefaultTypeInternal;
extern FileTransUpdateDefaultTypeInternal _FileTransUpdate_default_instance_;
class JsonMessage;
class JsonMessageDefaultTypeInternal;
extern JsonMessageDefaultTypeInternal _JsonMessage_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class OptionMessage;
class OptionMessageDefaultTypeInternal;
extern OptionMessageDefaultTypeInternal _OptionMessage_default_instance_;
class PeerInfo;
class PeerInfoDefaultTypeInternal;
extern PeerInfoDefaultTypeInternal _PeerInfo_default_instance_;
class ReadDirFiles;
class ReadDirFilesDefaultTypeInternal;
extern ReadDirFilesDefaultTypeInternal _ReadDirFiles_default_instance_;
namespace google {
namespace protobuf {
template<> ::ActionResult* Arena::CreateMaybeMessage<::ActionResult>(Arena*);
template<> ::FileAction* Arena::CreateMaybeMessage<::FileAction>(Arena*);
template<> ::FileCreate* Arena::CreateMaybeMessage<::FileCreate>(Arena*);
template<> ::FileDirectory* Arena::CreateMaybeMessage<::FileDirectory>(Arena*);
template<> ::FileEntry* Arena::CreateMaybeMessage<::FileEntry>(Arena*);
template<> ::FileRemove* Arena::CreateMaybeMessage<::FileRemove>(Arena*);
template<> ::FileRename* Arena::CreateMaybeMessage<::FileRename>(Arena*);
template<> ::FileResponse* Arena::CreateMaybeMessage<::FileResponse>(Arena*);
template<> ::FileTransBlock* Arena::CreateMaybeMessage<::FileTransBlock>(Arena*);
template<> ::FileTransCreate* Arena::CreateMaybeMessage<::FileTransCreate>(Arena*);
template<> ::FileTransJob* Arena::CreateMaybeMessage<::FileTransJob>(Arena*);
template<> ::FileTransJobCancel* Arena::CreateMaybeMessage<::FileTransJobCancel>(Arena*);
template<> ::FileTransJobReport* Arena::CreateMaybeMessage<::FileTransJobReport>(Arena*);
template<> ::FileTransResponse* Arena::CreateMaybeMessage<::FileTransResponse>(Arena*);
template<> ::FileTransUpdate* Arena::CreateMaybeMessage<::FileTransUpdate>(Arena*);
template<> ::JsonMessage* Arena::CreateMaybeMessage<::JsonMessage>(Arena*);
template<> ::LoginRequest* Arena::CreateMaybeMessage<::LoginRequest>(Arena*);
template<> ::LoginResponse* Arena::CreateMaybeMessage<::LoginResponse>(Arena*);
template<> ::OptionMessage* Arena::CreateMaybeMessage<::OptionMessage>(Arena*);
template<> ::PeerInfo* Arena::CreateMaybeMessage<::PeerInfo>(Arena*);
template<> ::ReadDirFiles* Arena::CreateMaybeMessage<::ReadDirFiles>(Arena*);
}  // namespace protobuf
}  // namespace google

enum FileType {
  DIR = 0,
  DIR_LINK = 1,
  FILE_B = 2,
  FILE_LINK = 3,
  FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool FileType_IsValid(int value);
const FileType FileType_MIN = DIR;
const FileType FileType_MAX = FILE_LINK;
const int FileType_ARRAYSIZE = FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileType_descriptor();
inline const ::std::string& FileType_Name(FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileType_descriptor(), value);
}
inline bool FileType_Parse(
    const ::std::string& name, FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileType>(
    FileType_descriptor(), name, value);
}
enum FileTransRe {
  IO_ERROR = 0,
  OK = 1,
  FINIASH = 2,
  FileTransRe_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  FileTransRe_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool FileTransRe_IsValid(int value);
const FileTransRe FileTransRe_MIN = IO_ERROR;
const FileTransRe FileTransRe_MAX = FINIASH;
const int FileTransRe_ARRAYSIZE = FileTransRe_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileTransRe_descriptor();
inline const ::std::string& FileTransRe_Name(FileTransRe value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileTransRe_descriptor(), value);
}
inline bool FileTransRe_Parse(
    const ::std::string& name, FileTransRe* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileTransRe>(
    FileTransRe_descriptor(), name, value);
}
// ===================================================================

class LoginRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(nullptr);
  }

  LoginRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OptionMessage options = 8;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 8;
  ::OptionMessage* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField< ::OptionMessage >*
      mutable_options();
  const ::OptionMessage& options(int index) const;
  ::OptionMessage* add_options();
  const ::google::protobuf::RepeatedPtrField< ::OptionMessage >&
      options() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes auth = 2;
  void clear_auth();
  static const int kAuthFieldNumber = 2;
  const ::std::string& auth() const;
  void set_auth(const ::std::string& value);
  #if LANG_CXX11
  void set_auth(::std::string&& value);
  #endif
  void set_auth(const char* value);
  void set_auth(const void* value, size_t size);
  ::std::string* mutable_auth();
  ::std::string* release_auth();
  void set_allocated_auth(::std::string* auth);

  // string my_uid = 4;
  void clear_my_uid();
  static const int kMyUidFieldNumber = 4;
  const ::std::string& my_uid() const;
  void set_my_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_my_uid(::std::string&& value);
  #endif
  void set_my_uid(const char* value);
  void set_my_uid(const char* value, size_t size);
  ::std::string* mutable_my_uid();
  ::std::string* release_my_uid();
  void set_allocated_my_uid(::std::string* my_uid);

  // string my_name = 5;
  void clear_my_name();
  static const int kMyNameFieldNumber = 5;
  const ::std::string& my_name() const;
  void set_my_name(const ::std::string& value);
  #if LANG_CXX11
  void set_my_name(::std::string&& value);
  #endif
  void set_my_name(const char* value);
  void set_my_name(const char* value, size_t size);
  ::std::string* mutable_my_name();
  ::std::string* release_my_name();
  void set_allocated_my_name(::std::string* my_name);

  // string session_id = 6;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 6;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // string version = 7;
  void clear_version();
  static const int kVersionFieldNumber = 7;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:LoginRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::OptionMessage > options_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr auth_;
  ::google::protobuf::internal::ArenaStringPtr my_uid_;
  ::google::protobuf::internal::ArenaStringPtr my_name_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LoginResponse& default_instance();

  enum UnionCase {
    kError = 1,
    kPeerInfo = 2,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LoginResponse* other);
  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const final {
    return CreateMaybeMessage<LoginResponse>(nullptr);
  }

  LoginResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes token = 3;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // string error = 1;
  private:
  bool has_error() const;
  public:
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .PeerInfo peer_info = 2;
  bool has_peer_info() const;
  void clear_peer_info();
  static const int kPeerInfoFieldNumber = 2;
  const ::PeerInfo& peer_info() const;
  ::PeerInfo* release_peer_info();
  ::PeerInfo* mutable_peer_info();
  void set_allocated_peer_info(::PeerInfo* peer_info);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:LoginResponse)
 private:
  class HasBitSetters;
  void set_has_error();
  void set_has_peer_info();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  union UnionUnion {
    UnionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::PeerInfo* peer_info_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class JsonMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JsonMessage) */ {
 public:
  JsonMessage();
  virtual ~JsonMessage();

  JsonMessage(const JsonMessage& from);

  inline JsonMessage& operator=(const JsonMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JsonMessage(JsonMessage&& from) noexcept
    : JsonMessage() {
    *this = ::std::move(from);
  }

  inline JsonMessage& operator=(JsonMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const JsonMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JsonMessage* internal_default_instance() {
    return reinterpret_cast<const JsonMessage*>(
               &_JsonMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(JsonMessage* other);
  friend void swap(JsonMessage& a, JsonMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JsonMessage* New() const final {
    return CreateMaybeMessage<JsonMessage>(nullptr);
  }

  JsonMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JsonMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JsonMessage& from);
  void MergeFrom(const JsonMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JsonMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string app = 1;
  void clear_app();
  static const int kAppFieldNumber = 1;
  const ::std::string& app() const;
  void set_app(const ::std::string& value);
  #if LANG_CXX11
  void set_app(::std::string&& value);
  #endif
  void set_app(const char* value);
  void set_app(const char* value, size_t size);
  ::std::string* mutable_app();
  ::std::string* release_app();
  void set_allocated_app(::std::string* app);

  // string json = 2;
  void clear_json();
  static const int kJsonFieldNumber = 2;
  const ::std::string& json() const;
  void set_json(const ::std::string& value);
  #if LANG_CXX11
  void set_json(::std::string&& value);
  #endif
  void set_json(const char* value);
  void set_json(const char* value, size_t size);
  ::std::string* mutable_json();
  ::std::string* release_json();
  void set_allocated_json(::std::string* json);

  // @@protoc_insertion_point(class_scope:JsonMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr app_;
  ::google::protobuf::internal::ArenaStringPtr json_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PeerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PeerInfo) */ {
 public:
  PeerInfo();
  virtual ~PeerInfo();

  PeerInfo(const PeerInfo& from);

  inline PeerInfo& operator=(const PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerInfo(PeerInfo&& from) noexcept
    : PeerInfo() {
    *this = ::std::move(from);
  }

  inline PeerInfo& operator=(PeerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PeerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerInfo* internal_default_instance() {
    return reinterpret_cast<const PeerInfo*>(
               &_PeerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PeerInfo* other);
  friend void swap(PeerInfo& a, PeerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerInfo* New() const final {
    return CreateMaybeMessage<PeerInfo>(nullptr);
  }

  PeerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PeerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PeerInfo& from);
  void MergeFrom(const PeerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string hostname = 2;
  void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // string platform = 3;
  void clear_platform();
  static const int kPlatformFieldNumber = 3;
  const ::std::string& platform() const;
  void set_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_platform(::std::string&& value);
  #endif
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  ::std::string* mutable_platform();
  ::std::string* release_platform();
  void set_allocated_platform(::std::string* platform);

  // string version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // bool privacy_mode = 5;
  void clear_privacy_mode();
  static const int kPrivacyModeFieldNumber = 5;
  bool privacy_mode() const;
  void set_privacy_mode(bool value);

  // @@protoc_insertion_point(class_scope:PeerInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr platform_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  bool privacy_mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class OptionMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptionMessage) */ {
 public:
  OptionMessage();
  virtual ~OptionMessage();

  OptionMessage(const OptionMessage& from);

  inline OptionMessage& operator=(const OptionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OptionMessage(OptionMessage&& from) noexcept
    : OptionMessage() {
    *this = ::std::move(from);
  }

  inline OptionMessage& operator=(OptionMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OptionMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OptionMessage* internal_default_instance() {
    return reinterpret_cast<const OptionMessage*>(
               &_OptionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(OptionMessage* other);
  friend void swap(OptionMessage& a, OptionMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OptionMessage* New() const final {
    return CreateMaybeMessage<OptionMessage>(nullptr);
  }

  OptionMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OptionMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OptionMessage& from);
  void MergeFrom(const OptionMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string feature = 1;
  void clear_feature();
  static const int kFeatureFieldNumber = 1;
  const ::std::string& feature() const;
  void set_feature(const ::std::string& value);
  #if LANG_CXX11
  void set_feature(::std::string&& value);
  #endif
  void set_feature(const char* value);
  void set_feature(const char* value, size_t size);
  ::std::string* mutable_feature();
  ::std::string* release_feature();
  void set_allocated_feature(::std::string* feature);

  // bool enable = 2;
  void clear_enable();
  static const int kEnableFieldNumber = 2;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:OptionMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr feature_;
  bool enable_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileEntry) */ {
 public:
  FileEntry();
  virtual ~FileEntry();

  FileEntry(const FileEntry& from);

  inline FileEntry& operator=(const FileEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileEntry(FileEntry&& from) noexcept
    : FileEntry() {
    *this = ::std::move(from);
  }

  inline FileEntry& operator=(FileEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileEntry* internal_default_instance() {
    return reinterpret_cast<const FileEntry*>(
               &_FileEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FileEntry* other);
  friend void swap(FileEntry& a, FileEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileEntry* New() const final {
    return CreateMaybeMessage<FileEntry>(nullptr);
  }

  FileEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileEntry& from);
  void MergeFrom(const FileEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .FileType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::FileType type() const;
  void set_type(::FileType value);

  // bool hidden = 3;
  void clear_hidden();
  static const int kHiddenFieldNumber = 3;
  bool hidden() const;
  void set_hidden(bool value);

  // int64 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int64 size() const;
  void set_size(::google::protobuf::int64 value);

  // int64 modified_time = 5;
  void clear_modified_time();
  static const int kModifiedTimeFieldNumber = 5;
  ::google::protobuf::int64 modified_time() const;
  void set_modified_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:FileEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  bool hidden_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 modified_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileDirectory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileDirectory) */ {
 public:
  FileDirectory();
  virtual ~FileDirectory();

  FileDirectory(const FileDirectory& from);

  inline FileDirectory& operator=(const FileDirectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileDirectory(FileDirectory&& from) noexcept
    : FileDirectory() {
    *this = ::std::move(from);
  }

  inline FileDirectory& operator=(FileDirectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileDirectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileDirectory* internal_default_instance() {
    return reinterpret_cast<const FileDirectory*>(
               &_FileDirectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FileDirectory* other);
  friend void swap(FileDirectory& a, FileDirectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileDirectory* New() const final {
    return CreateMaybeMessage<FileDirectory>(nullptr);
  }

  FileDirectory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileDirectory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileDirectory& from);
  void MergeFrom(const FileDirectory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileDirectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FileEntry entries = 3;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 3;
  ::FileEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::FileEntry >*
      mutable_entries();
  const ::FileEntry& entries(int index) const;
  ::FileEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::FileEntry >&
      entries() const;

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileDirectory)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::FileEntry > entries_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ActionResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ActionResult) */ {
 public:
  ActionResult();
  virtual ~ActionResult();

  ActionResult(const ActionResult& from);

  inline ActionResult& operator=(const ActionResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionResult(ActionResult&& from) noexcept
    : ActionResult() {
    *this = ::std::move(from);
  }

  inline ActionResult& operator=(ActionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ActionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionResult* internal_default_instance() {
    return reinterpret_cast<const ActionResult*>(
               &_ActionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ActionResult* other);
  friend void swap(ActionResult& a, ActionResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionResult* New() const final {
    return CreateMaybeMessage<ActionResult>(nullptr);
  }

  ActionResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionResult& from);
  void MergeFrom(const ActionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // bool result = 3;
  void clear_result();
  static const int kResultFieldNumber = 3;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:ActionResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  bool result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ReadDirFiles final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReadDirFiles) */ {
 public:
  ReadDirFiles();
  virtual ~ReadDirFiles();

  ReadDirFiles(const ReadDirFiles& from);

  inline ReadDirFiles& operator=(const ReadDirFiles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadDirFiles(ReadDirFiles&& from) noexcept
    : ReadDirFiles() {
    *this = ::std::move(from);
  }

  inline ReadDirFiles& operator=(ReadDirFiles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReadDirFiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadDirFiles* internal_default_instance() {
    return reinterpret_cast<const ReadDirFiles*>(
               &_ReadDirFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ReadDirFiles* other);
  friend void swap(ReadDirFiles& a, ReadDirFiles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadDirFiles* New() const final {
    return CreateMaybeMessage<ReadDirFiles>(nullptr);
  }

  ReadDirFiles* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadDirFiles>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadDirFiles& from);
  void MergeFrom(const ReadDirFiles& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadDirFiles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // bool include_hidden = 3;
  void clear_include_hidden();
  static const int kIncludeHiddenFieldNumber = 3;
  bool include_hidden() const;
  void set_include_hidden(bool value);

  // bool recursive = 4;
  void clear_recursive();
  static const int kRecursiveFieldNumber = 4;
  bool recursive() const;
  void set_recursive(bool value);

  // @@protoc_insertion_point(class_scope:ReadDirFiles)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  bool include_hidden_;
  bool recursive_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileRemove final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileRemove) */ {
 public:
  FileRemove();
  virtual ~FileRemove();

  FileRemove(const FileRemove& from);

  inline FileRemove& operator=(const FileRemove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileRemove(FileRemove&& from) noexcept
    : FileRemove() {
    *this = ::std::move(from);
  }

  inline FileRemove& operator=(FileRemove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileRemove& default_instance();

  enum UnionCase {
    kRecursive = 3,
    kFileNum = 4,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileRemove* internal_default_instance() {
    return reinterpret_cast<const FileRemove*>(
               &_FileRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(FileRemove* other);
  friend void swap(FileRemove& a, FileRemove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileRemove* New() const final {
    return CreateMaybeMessage<FileRemove>(nullptr);
  }

  FileRemove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileRemove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileRemove& from);
  void MergeFrom(const FileRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRemove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // bool recursive = 3;
  private:
  bool has_recursive() const;
  public:
  void clear_recursive();
  static const int kRecursiveFieldNumber = 3;
  bool recursive() const;
  void set_recursive(bool value);

  // uint32 file_num = 4;
  private:
  bool has_file_num() const;
  public:
  void clear_file_num();
  static const int kFileNumFieldNumber = 4;
  ::google::protobuf::uint32 file_num() const;
  void set_file_num(::google::protobuf::uint32 value);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:FileRemove)
 private:
  class HasBitSetters;
  void set_has_recursive();
  void set_has_file_num();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  union UnionUnion {
    UnionUnion() {}
    bool recursive_;
    ::google::protobuf::uint32 file_num_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileRename final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileRename) */ {
 public:
  FileRename();
  virtual ~FileRename();

  FileRename(const FileRename& from);

  inline FileRename& operator=(const FileRename& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileRename(FileRename&& from) noexcept
    : FileRename() {
    *this = ::std::move(from);
  }

  inline FileRename& operator=(FileRename&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileRename& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileRename* internal_default_instance() {
    return reinterpret_cast<const FileRename*>(
               &_FileRename_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(FileRename* other);
  friend void swap(FileRename& a, FileRename& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileRename* New() const final {
    return CreateMaybeMessage<FileRename>(nullptr);
  }

  FileRename* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileRename>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileRename& from);
  void MergeFrom(const FileRename& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRename* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileRename)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileCreate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileCreate) */ {
 public:
  FileCreate();
  virtual ~FileCreate();

  FileCreate(const FileCreate& from);

  inline FileCreate& operator=(const FileCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileCreate(FileCreate&& from) noexcept
    : FileCreate() {
    *this = ::std::move(from);
  }

  inline FileCreate& operator=(FileCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileCreate* internal_default_instance() {
    return reinterpret_cast<const FileCreate*>(
               &_FileCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FileCreate* other);
  friend void swap(FileCreate& a, FileCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileCreate* New() const final {
    return CreateMaybeMessage<FileCreate>(nullptr);
  }

  FileCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileCreate& from);
  void MergeFrom(const FileCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // bool is_dir = 3;
  void clear_is_dir();
  static const int kIsDirFieldNumber = 3;
  bool is_dir() const;
  void set_is_dir(bool value);

  // @@protoc_insertion_point(class_scope:FileCreate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 id_;
  bool is_dir_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileAction) */ {
 public:
  FileAction();
  virtual ~FileAction();

  FileAction(const FileAction& from);

  inline FileAction& operator=(const FileAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileAction(FileAction&& from) noexcept
    : FileAction() {
    *this = ::std::move(from);
  }

  inline FileAction& operator=(FileAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileAction& default_instance();

  enum UnionCase {
    kReadFiles = 1,
    kCreate = 2,
    kRemove = 3,
    kRename = 4,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileAction* internal_default_instance() {
    return reinterpret_cast<const FileAction*>(
               &_FileAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(FileAction* other);
  friend void swap(FileAction& a, FileAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileAction* New() const final {
    return CreateMaybeMessage<FileAction>(nullptr);
  }

  FileAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileAction& from);
  void MergeFrom(const FileAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ReadDirFiles read_files = 1;
  bool has_read_files() const;
  void clear_read_files();
  static const int kReadFilesFieldNumber = 1;
  const ::ReadDirFiles& read_files() const;
  ::ReadDirFiles* release_read_files();
  ::ReadDirFiles* mutable_read_files();
  void set_allocated_read_files(::ReadDirFiles* read_files);

  // .FileCreate create = 2;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 2;
  const ::FileCreate& create() const;
  ::FileCreate* release_create();
  ::FileCreate* mutable_create();
  void set_allocated_create(::FileCreate* create);

  // .FileRemove remove = 3;
  bool has_remove() const;
  void clear_remove();
  static const int kRemoveFieldNumber = 3;
  const ::FileRemove& remove() const;
  ::FileRemove* release_remove();
  ::FileRemove* mutable_remove();
  void set_allocated_remove(::FileRemove* remove);

  // .FileRename rename = 4;
  bool has_rename() const;
  void clear_rename();
  static const int kRenameFieldNumber = 4;
  const ::FileRename& rename() const;
  ::FileRename* release_rename();
  ::FileRename* mutable_rename();
  void set_allocated_rename(::FileRename* rename);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:FileAction)
 private:
  class HasBitSetters;
  void set_has_read_files();
  void set_has_create();
  void set_has_remove();
  void set_has_rename();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union UnionUnion {
    UnionUnion() {}
    ::ReadDirFiles* read_files_;
    ::FileCreate* create_;
    ::FileRemove* remove_;
    ::FileRename* rename_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileResponse) */ {
 public:
  FileResponse();
  virtual ~FileResponse();

  FileResponse(const FileResponse& from);

  inline FileResponse& operator=(const FileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileResponse(FileResponse&& from) noexcept
    : FileResponse() {
    *this = ::std::move(from);
  }

  inline FileResponse& operator=(FileResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileResponse& default_instance();

  enum UnionCase {
    kDir = 1,
    kResult = 2,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileResponse* internal_default_instance() {
    return reinterpret_cast<const FileResponse*>(
               &_FileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(FileResponse* other);
  friend void swap(FileResponse& a, FileResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileResponse* New() const final {
    return CreateMaybeMessage<FileResponse>(nullptr);
  }

  FileResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileResponse& from);
  void MergeFrom(const FileResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .FileDirectory dir = 1;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 1;
  const ::FileDirectory& dir() const;
  ::FileDirectory* release_dir();
  ::FileDirectory* mutable_dir();
  void set_allocated_dir(::FileDirectory* dir);

  // .ActionResult result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  const ::ActionResult& result() const;
  ::ActionResult* release_result();
  ::ActionResult* mutable_result();
  void set_allocated_result(::ActionResult* result);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:FileResponse)
 private:
  class HasBitSetters;
  void set_has_dir();
  void set_has_result();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union UnionUnion {
    UnionUnion() {}
    ::FileDirectory* dir_;
    ::ActionResult* result_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransResponse) */ {
 public:
  FileTransResponse();
  virtual ~FileTransResponse();

  FileTransResponse(const FileTransResponse& from);

  inline FileTransResponse& operator=(const FileTransResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransResponse(FileTransResponse&& from) noexcept
    : FileTransResponse() {
    *this = ::std::move(from);
  }

  inline FileTransResponse& operator=(FileTransResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransResponse* internal_default_instance() {
    return reinterpret_cast<const FileTransResponse*>(
               &_FileTransResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(FileTransResponse* other);
  friend void swap(FileTransResponse& a, FileTransResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransResponse* New() const final {
    return CreateMaybeMessage<FileTransResponse>(nullptr);
  }

  FileTransResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransResponse& from);
  void MergeFrom(const FileTransResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // .FileTransRe result = 3;
  void clear_result();
  static const int kResultFieldNumber = 3;
  ::FileTransRe result() const;
  void set_result(::FileTransRe value);

  // @@protoc_insertion_point(class_scope:FileTransResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  int result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransJob final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransJob) */ {
 public:
  FileTransJob();
  virtual ~FileTransJob();

  FileTransJob(const FileTransJob& from);

  inline FileTransJob& operator=(const FileTransJob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransJob(FileTransJob&& from) noexcept
    : FileTransJob() {
    *this = ::std::move(from);
  }

  inline FileTransJob& operator=(FileTransJob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransJob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransJob* internal_default_instance() {
    return reinterpret_cast<const FileTransJob*>(
               &_FileTransJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(FileTransJob* other);
  friend void swap(FileTransJob& a, FileTransJob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransJob* New() const final {
    return CreateMaybeMessage<FileTransJob>(nullptr);
  }

  FileTransJob* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransJob>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransJob& from);
  void MergeFrom(const FileTransJob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransJob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string app_who = 6;
  void clear_app_who();
  static const int kAppWhoFieldNumber = 6;
  const ::std::string& app_who() const;
  void set_app_who(const ::std::string& value);
  #if LANG_CXX11
  void set_app_who(::std::string&& value);
  #endif
  void set_app_who(const char* value);
  void set_app_who(const char* value, size_t size);
  ::std::string* mutable_app_who();
  ::std::string* release_app_who();
  void set_allocated_app_who(::std::string* app_who);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // bool include_hidden = 3;
  void clear_include_hidden();
  static const int kIncludeHiddenFieldNumber = 3;
  bool include_hidden() const;
  void set_include_hidden(bool value);

  // bool recursive = 4;
  void clear_recursive();
  static const int kRecursiveFieldNumber = 4;
  bool recursive() const;
  void set_recursive(bool value);

  // bool push = 5;
  void clear_push();
  static const int kPushFieldNumber = 5;
  bool push() const;
  void set_push(bool value);

  // @@protoc_insertion_point(class_scope:FileTransJob)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr app_who_;
  ::google::protobuf::int32 job_id_;
  bool include_hidden_;
  bool recursive_;
  bool push_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransCreate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransCreate) */ {
 public:
  FileTransCreate();
  virtual ~FileTransCreate();

  FileTransCreate(const FileTransCreate& from);

  inline FileTransCreate& operator=(const FileTransCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransCreate(FileTransCreate&& from) noexcept
    : FileTransCreate() {
    *this = ::std::move(from);
  }

  inline FileTransCreate& operator=(FileTransCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransCreate* internal_default_instance() {
    return reinterpret_cast<const FileTransCreate*>(
               &_FileTransCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(FileTransCreate* other);
  friend void swap(FileTransCreate& a, FileTransCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransCreate* New() const final {
    return CreateMaybeMessage<FileTransCreate>(nullptr);
  }

  FileTransCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransCreate& from);
  void MergeFrom(const FileTransCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sub_dir = 3;
  void clear_sub_dir();
  static const int kSubDirFieldNumber = 3;
  const ::std::string& sub_dir() const;
  void set_sub_dir(const ::std::string& value);
  #if LANG_CXX11
  void set_sub_dir(::std::string&& value);
  #endif
  void set_sub_dir(const char* value);
  void set_sub_dir(const char* value, size_t size);
  ::std::string* mutable_sub_dir();
  ::std::string* release_sub_dir();
  void set_allocated_sub_dir(::std::string* sub_dir);

  // .FileEntry entry = 4;
  bool has_entry() const;
  void clear_entry();
  static const int kEntryFieldNumber = 4;
  const ::FileEntry& entry() const;
  ::FileEntry* release_entry();
  ::FileEntry* mutable_entry();
  void set_allocated_entry(::FileEntry* entry);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // int32 file_id = 2;
  void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  ::google::protobuf::int32 file_id() const;
  void set_file_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileTransCreate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sub_dir_;
  ::FileEntry* entry_;
  ::google::protobuf::int32 job_id_;
  ::google::protobuf::int32 file_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransBlock final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransBlock) */ {
 public:
  FileTransBlock();
  virtual ~FileTransBlock();

  FileTransBlock(const FileTransBlock& from);

  inline FileTransBlock& operator=(const FileTransBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransBlock(FileTransBlock&& from) noexcept
    : FileTransBlock() {
    *this = ::std::move(from);
  }

  inline FileTransBlock& operator=(FileTransBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransBlock* internal_default_instance() {
    return reinterpret_cast<const FileTransBlock*>(
               &_FileTransBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(FileTransBlock* other);
  friend void swap(FileTransBlock& a, FileTransBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransBlock* New() const final {
    return CreateMaybeMessage<FileTransBlock>(nullptr);
  }

  FileTransBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransBlock>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransBlock& from);
  void MergeFrom(const FileTransBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 3;
  void clear_filename();
  static const int kFilenameFieldNumber = 3;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // bytes data = 5;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // int32 file_id = 2;
  void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  ::google::protobuf::int32 file_id() const;
  void set_file_id(::google::protobuf::int32 value);

  // uint32 blk_id = 4;
  void clear_blk_id();
  static const int kBlkIdFieldNumber = 4;
  ::google::protobuf::uint32 blk_id() const;
  void set_blk_id(::google::protobuf::uint32 value);

  // bool compressed = 6;
  void clear_compressed();
  static const int kCompressedFieldNumber = 6;
  bool compressed() const;
  void set_compressed(bool value);

  // @@protoc_insertion_point(class_scope:FileTransBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 job_id_;
  ::google::protobuf::int32 file_id_;
  ::google::protobuf::uint32 blk_id_;
  bool compressed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransJobCancel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransJobCancel) */ {
 public:
  FileTransJobCancel();
  virtual ~FileTransJobCancel();

  FileTransJobCancel(const FileTransJobCancel& from);

  inline FileTransJobCancel& operator=(const FileTransJobCancel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransJobCancel(FileTransJobCancel&& from) noexcept
    : FileTransJobCancel() {
    *this = ::std::move(from);
  }

  inline FileTransJobCancel& operator=(FileTransJobCancel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransJobCancel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransJobCancel* internal_default_instance() {
    return reinterpret_cast<const FileTransJobCancel*>(
               &_FileTransJobCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(FileTransJobCancel* other);
  friend void swap(FileTransJobCancel& a, FileTransJobCancel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransJobCancel* New() const final {
    return CreateMaybeMessage<FileTransJobCancel>(nullptr);
  }

  FileTransJobCancel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransJobCancel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransJobCancel& from);
  void MergeFrom(const FileTransJobCancel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransJobCancel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileTransJobCancel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int32 job_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransJobReport final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransJobReport) */ {
 public:
  FileTransJobReport();
  virtual ~FileTransJobReport();

  FileTransJobReport(const FileTransJobReport& from);

  inline FileTransJobReport& operator=(const FileTransJobReport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransJobReport(FileTransJobReport&& from) noexcept
    : FileTransJobReport() {
    *this = ::std::move(from);
  }

  inline FileTransJobReport& operator=(FileTransJobReport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransJobReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransJobReport* internal_default_instance() {
    return reinterpret_cast<const FileTransJobReport*>(
               &_FileTransJobReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(FileTransJobReport* other);
  friend void swap(FileTransJobReport& a, FileTransJobReport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransJobReport* New() const final {
    return CreateMaybeMessage<FileTransJobReport>(nullptr);
  }

  FileTransJobReport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransJobReport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransJobReport& from);
  void MergeFrom(const FileTransJobReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransJobReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string error = 3;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // int32 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int32 job_id() const;
  void set_job_id(::google::protobuf::int32 value);

  // .FileTransRe result = 4;
  void clear_result();
  static const int kResultFieldNumber = 4;
  ::FileTransRe result() const;
  void set_result(::FileTransRe value);

  // @@protoc_insertion_point(class_scope:FileTransJobReport)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::int32 job_id_;
  int result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class FileTransUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileTransUpdate) */ {
 public:
  FileTransUpdate();
  virtual ~FileTransUpdate();

  FileTransUpdate(const FileTransUpdate& from);

  inline FileTransUpdate& operator=(const FileTransUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransUpdate(FileTransUpdate&& from) noexcept
    : FileTransUpdate() {
    *this = ::std::move(from);
  }

  inline FileTransUpdate& operator=(FileTransUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FileTransUpdate& default_instance();

  enum UnionCase {
    kCancel = 1,
    kReport = 2,
    UNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransUpdate* internal_default_instance() {
    return reinterpret_cast<const FileTransUpdate*>(
               &_FileTransUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(FileTransUpdate* other);
  friend void swap(FileTransUpdate& a, FileTransUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransUpdate* New() const final {
    return CreateMaybeMessage<FileTransUpdate>(nullptr);
  }

  FileTransUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileTransUpdate& from);
  void MergeFrom(const FileTransUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .FileTransJobCancel cancel = 1;
  bool has_cancel() const;
  void clear_cancel();
  static const int kCancelFieldNumber = 1;
  const ::FileTransJobCancel& cancel() const;
  ::FileTransJobCancel* release_cancel();
  ::FileTransJobCancel* mutable_cancel();
  void set_allocated_cancel(::FileTransJobCancel* cancel);

  // .FileTransJobReport report = 2;
  bool has_report() const;
  void clear_report();
  static const int kReportFieldNumber = 2;
  const ::FileTransJobReport& report() const;
  ::FileTransJobReport* release_report();
  ::FileTransJobReport* mutable_report();
  void set_allocated_report(::FileTransJobReport* report);

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:FileTransUpdate)
 private:
  class HasBitSetters;
  void set_has_cancel();
  void set_has_report();

  inline bool has_union() const;
  inline void clear_has_union();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union UnionUnion {
    UnionUnion() {}
    ::FileTransJobCancel* cancel_;
    ::FileTransJobReport* report_;
  } union_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================

class RemoteService_Stub;

class RemoteService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline RemoteService() {};
 public:
  virtual ~RemoteService();

  typedef RemoteService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void login(::google::protobuf::RpcController* controller,
                       const ::LoginRequest* request,
                       ::LoginResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void query_peerinfo(::google::protobuf::RpcController* controller,
                       const ::PeerInfo* request,
                       ::PeerInfo* response,
                       ::google::protobuf::Closure* done);
  virtual void misc(::google::protobuf::RpcController* controller,
                       const ::JsonMessage* request,
                       ::JsonMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void fsaction(::google::protobuf::RpcController* controller,
                       const ::FileAction* request,
                       ::FileResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void filetrans_job(::google::protobuf::RpcController* controller,
                       const ::FileTransJob* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void filetrans_create(::google::protobuf::RpcController* controller,
                       const ::FileTransCreate* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void filetrans_block(::google::protobuf::RpcController* controller,
                       const ::FileTransBlock* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void filetrans_update(::google::protobuf::RpcController* controller,
                       const ::FileTransUpdate* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RemoteService);
};

class RemoteService_Stub : public RemoteService {
 public:
  RemoteService_Stub(::google::protobuf::RpcChannel* channel);
  RemoteService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~RemoteService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements RemoteService ------------------------------------------

  void login(::google::protobuf::RpcController* controller,
                       const ::LoginRequest* request,
                       ::LoginResponse* response,
                       ::google::protobuf::Closure* done);
  void query_peerinfo(::google::protobuf::RpcController* controller,
                       const ::PeerInfo* request,
                       ::PeerInfo* response,
                       ::google::protobuf::Closure* done);
  void misc(::google::protobuf::RpcController* controller,
                       const ::JsonMessage* request,
                       ::JsonMessage* response,
                       ::google::protobuf::Closure* done);
  void fsaction(::google::protobuf::RpcController* controller,
                       const ::FileAction* request,
                       ::FileResponse* response,
                       ::google::protobuf::Closure* done);
  void filetrans_job(::google::protobuf::RpcController* controller,
                       const ::FileTransJob* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  void filetrans_create(::google::protobuf::RpcController* controller,
                       const ::FileTransCreate* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  void filetrans_block(::google::protobuf::RpcController* controller,
                       const ::FileTransBlock* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
  void filetrans_update(::google::protobuf::RpcController* controller,
                       const ::FileTransUpdate* request,
                       ::FileTransResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RemoteService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// string name = 1;
inline void LoginRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::name() const {
  // @@protoc_insertion_point(field_get:LoginRequest.name)
  return name_.GetNoArena();
}
inline void LoginRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.name)
}
#if LANG_CXX11
inline void LoginRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.name)
}
#endif
inline void LoginRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.name)
}
inline void LoginRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.name)
}
inline ::std::string* LoginRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_name() {
  // @@protoc_insertion_point(field_release:LoginRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.name)
}

// bytes auth = 2;
inline void LoginRequest::clear_auth() {
  auth_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::auth() const {
  // @@protoc_insertion_point(field_get:LoginRequest.auth)
  return auth_.GetNoArena();
}
inline void LoginRequest::set_auth(const ::std::string& value) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.auth)
}
#if LANG_CXX11
inline void LoginRequest::set_auth(::std::string&& value) {
  
  auth_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.auth)
}
#endif
inline void LoginRequest::set_auth(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.auth)
}
inline void LoginRequest::set_auth(const void* value, size_t size) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.auth)
}
inline ::std::string* LoginRequest::mutable_auth() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.auth)
  return auth_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_auth() {
  // @@protoc_insertion_point(field_release:LoginRequest.auth)
  
  return auth_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_auth(::std::string* auth) {
  if (auth != nullptr) {
    
  } else {
    
  }
  auth_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.auth)
}

// string my_uid = 4;
inline void LoginRequest::clear_my_uid() {
  my_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::my_uid() const {
  // @@protoc_insertion_point(field_get:LoginRequest.my_uid)
  return my_uid_.GetNoArena();
}
inline void LoginRequest::set_my_uid(const ::std::string& value) {
  
  my_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.my_uid)
}
#if LANG_CXX11
inline void LoginRequest::set_my_uid(::std::string&& value) {
  
  my_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.my_uid)
}
#endif
inline void LoginRequest::set_my_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  my_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.my_uid)
}
inline void LoginRequest::set_my_uid(const char* value, size_t size) {
  
  my_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.my_uid)
}
inline ::std::string* LoginRequest::mutable_my_uid() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.my_uid)
  return my_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_my_uid() {
  // @@protoc_insertion_point(field_release:LoginRequest.my_uid)
  
  return my_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_my_uid(::std::string* my_uid) {
  if (my_uid != nullptr) {
    
  } else {
    
  }
  my_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), my_uid);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.my_uid)
}

// string my_name = 5;
inline void LoginRequest::clear_my_name() {
  my_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::my_name() const {
  // @@protoc_insertion_point(field_get:LoginRequest.my_name)
  return my_name_.GetNoArena();
}
inline void LoginRequest::set_my_name(const ::std::string& value) {
  
  my_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.my_name)
}
#if LANG_CXX11
inline void LoginRequest::set_my_name(::std::string&& value) {
  
  my_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.my_name)
}
#endif
inline void LoginRequest::set_my_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  my_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.my_name)
}
inline void LoginRequest::set_my_name(const char* value, size_t size) {
  
  my_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.my_name)
}
inline ::std::string* LoginRequest::mutable_my_name() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.my_name)
  return my_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_my_name() {
  // @@protoc_insertion_point(field_release:LoginRequest.my_name)
  
  return my_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_my_name(::std::string* my_name) {
  if (my_name != nullptr) {
    
  } else {
    
  }
  my_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), my_name);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.my_name)
}

// string session_id = 6;
inline void LoginRequest::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::session_id() const {
  // @@protoc_insertion_point(field_get:LoginRequest.session_id)
  return session_id_.GetNoArena();
}
inline void LoginRequest::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.session_id)
}
#if LANG_CXX11
inline void LoginRequest::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.session_id)
}
#endif
inline void LoginRequest::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.session_id)
}
inline void LoginRequest::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.session_id)
}
inline ::std::string* LoginRequest::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:LoginRequest.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_session_id(::std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.session_id)
}

// string version = 7;
inline void LoginRequest::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::version() const {
  // @@protoc_insertion_point(field_get:LoginRequest.version)
  return version_.GetNoArena();
}
inline void LoginRequest::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.version)
}
#if LANG_CXX11
inline void LoginRequest::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.version)
}
#endif
inline void LoginRequest::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.version)
}
inline void LoginRequest::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.version)
}
inline ::std::string* LoginRequest::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_version() {
  // @@protoc_insertion_point(field_release:LoginRequest.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.version)
}

// repeated .OptionMessage options = 8;
inline int LoginRequest::options_size() const {
  return options_.size();
}
inline void LoginRequest::clear_options() {
  options_.Clear();
}
inline ::OptionMessage* LoginRequest::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:LoginRequest.options)
  return options_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::OptionMessage >*
LoginRequest::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:LoginRequest.options)
  return &options_;
}
inline const ::OptionMessage& LoginRequest::options(int index) const {
  // @@protoc_insertion_point(field_get:LoginRequest.options)
  return options_.Get(index);
}
inline ::OptionMessage* LoginRequest::add_options() {
  // @@protoc_insertion_point(field_add:LoginRequest.options)
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OptionMessage >&
LoginRequest::options() const {
  // @@protoc_insertion_point(field_list:LoginRequest.options)
  return options_;
}

// -------------------------------------------------------------------

// LoginResponse

// string error = 1;
inline bool LoginResponse::has_error() const {
  return union_case() == kError;
}
inline void LoginResponse::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void LoginResponse::clear_error() {
  if (has_error()) {
    union_.error_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_union();
  }
}
inline const ::std::string& LoginResponse::error() const {
  // @@protoc_insertion_point(field_get:LoginResponse.error)
  if (has_error()) {
    return union_.error_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void LoginResponse::set_error(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:LoginResponse.error)
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginResponse.error)
}
#if LANG_CXX11
inline void LoginResponse::set_error(::std::string&& value) {
  // @@protoc_insertion_point(field_set:LoginResponse.error)
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginResponse.error)
}
#endif
inline void LoginResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginResponse.error)
}
inline void LoginResponse::set_error(const char* value, size_t size) {
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  union_.error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginResponse.error)
}
inline ::std::string* LoginResponse::mutable_error() {
  if (!has_error()) {
    clear_union();
    set_has_error();
    union_.error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:LoginResponse.error)
  return union_.error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse::release_error() {
  // @@protoc_insertion_point(field_release:LoginResponse.error)
  if (has_error()) {
    clear_has_union();
    return union_.error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void LoginResponse::set_allocated_error(::std::string* error) {
  if (has_union()) {
    clear_union();
  }
  if (error != nullptr) {
    set_has_error();
    union_.error_.UnsafeSetDefault(error);
  }
  // @@protoc_insertion_point(field_set_allocated:LoginResponse.error)
}

// .PeerInfo peer_info = 2;
inline bool LoginResponse::has_peer_info() const {
  return union_case() == kPeerInfo;
}
inline void LoginResponse::set_has_peer_info() {
  _oneof_case_[0] = kPeerInfo;
}
inline void LoginResponse::clear_peer_info() {
  if (has_peer_info()) {
    delete union_.peer_info_;
    clear_has_union();
  }
}
inline ::PeerInfo* LoginResponse::release_peer_info() {
  // @@protoc_insertion_point(field_release:LoginResponse.peer_info)
  if (has_peer_info()) {
    clear_has_union();
      ::PeerInfo* temp = union_.peer_info_;
    union_.peer_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PeerInfo& LoginResponse::peer_info() const {
  // @@protoc_insertion_point(field_get:LoginResponse.peer_info)
  return has_peer_info()
      ? *union_.peer_info_
      : *reinterpret_cast< ::PeerInfo*>(&::_PeerInfo_default_instance_);
}
inline ::PeerInfo* LoginResponse::mutable_peer_info() {
  if (!has_peer_info()) {
    clear_union();
    set_has_peer_info();
    union_.peer_info_ = CreateMaybeMessage< ::PeerInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LoginResponse.peer_info)
  return union_.peer_info_;
}

// bytes token = 3;
inline void LoginResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:LoginResponse.token)
  return token_.GetNoArena();
}
inline void LoginResponse::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginResponse.token)
}
#if LANG_CXX11
inline void LoginResponse::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginResponse.token)
}
#endif
inline void LoginResponse::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginResponse.token)
}
inline void LoginResponse::set_token(const void* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginResponse.token)
}
inline ::std::string* LoginResponse::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:LoginResponse.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse::release_token() {
  // @@protoc_insertion_point(field_release:LoginResponse.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_token(::std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:LoginResponse.token)
}

inline bool LoginResponse::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void LoginResponse::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline LoginResponse::UnionCase LoginResponse::union_case() const {
  return LoginResponse::UnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// JsonMessage

// string app = 1;
inline void JsonMessage::clear_app() {
  app_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JsonMessage::app() const {
  // @@protoc_insertion_point(field_get:JsonMessage.app)
  return app_.GetNoArena();
}
inline void JsonMessage::set_app(const ::std::string& value) {
  
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:JsonMessage.app)
}
#if LANG_CXX11
inline void JsonMessage::set_app(::std::string&& value) {
  
  app_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:JsonMessage.app)
}
#endif
inline void JsonMessage::set_app(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:JsonMessage.app)
}
inline void JsonMessage::set_app(const char* value, size_t size) {
  
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:JsonMessage.app)
}
inline ::std::string* JsonMessage::mutable_app() {
  
  // @@protoc_insertion_point(field_mutable:JsonMessage.app)
  return app_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JsonMessage::release_app() {
  // @@protoc_insertion_point(field_release:JsonMessage.app)
  
  return app_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JsonMessage::set_allocated_app(::std::string* app) {
  if (app != nullptr) {
    
  } else {
    
  }
  app_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app);
  // @@protoc_insertion_point(field_set_allocated:JsonMessage.app)
}

// string json = 2;
inline void JsonMessage::clear_json() {
  json_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JsonMessage::json() const {
  // @@protoc_insertion_point(field_get:JsonMessage.json)
  return json_.GetNoArena();
}
inline void JsonMessage::set_json(const ::std::string& value) {
  
  json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:JsonMessage.json)
}
#if LANG_CXX11
inline void JsonMessage::set_json(::std::string&& value) {
  
  json_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:JsonMessage.json)
}
#endif
inline void JsonMessage::set_json(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:JsonMessage.json)
}
inline void JsonMessage::set_json(const char* value, size_t size) {
  
  json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:JsonMessage.json)
}
inline ::std::string* JsonMessage::mutable_json() {
  
  // @@protoc_insertion_point(field_mutable:JsonMessage.json)
  return json_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JsonMessage::release_json() {
  // @@protoc_insertion_point(field_release:JsonMessage.json)
  
  return json_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JsonMessage::set_allocated_json(::std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  json_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), json);
  // @@protoc_insertion_point(field_set_allocated:JsonMessage.json)
}

// -------------------------------------------------------------------

// PeerInfo

// string username = 1;
inline void PeerInfo::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerInfo::username() const {
  // @@protoc_insertion_point(field_get:PeerInfo.username)
  return username_.GetNoArena();
}
inline void PeerInfo::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PeerInfo.username)
}
#if LANG_CXX11
inline void PeerInfo::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PeerInfo.username)
}
#endif
inline void PeerInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PeerInfo.username)
}
inline void PeerInfo::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PeerInfo.username)
}
inline ::std::string* PeerInfo::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:PeerInfo.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerInfo::release_username() {
  // @@protoc_insertion_point(field_release:PeerInfo.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerInfo::set_allocated_username(::std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:PeerInfo.username)
}

// string hostname = 2;
inline void PeerInfo::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerInfo::hostname() const {
  // @@protoc_insertion_point(field_get:PeerInfo.hostname)
  return hostname_.GetNoArena();
}
inline void PeerInfo::set_hostname(const ::std::string& value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PeerInfo.hostname)
}
#if LANG_CXX11
inline void PeerInfo::set_hostname(::std::string&& value) {
  
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PeerInfo.hostname)
}
#endif
inline void PeerInfo::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PeerInfo.hostname)
}
inline void PeerInfo::set_hostname(const char* value, size_t size) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PeerInfo.hostname)
}
inline ::std::string* PeerInfo::mutable_hostname() {
  
  // @@protoc_insertion_point(field_mutable:PeerInfo.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:PeerInfo.hostname)
  
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:PeerInfo.hostname)
}

// string platform = 3;
inline void PeerInfo::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerInfo::platform() const {
  // @@protoc_insertion_point(field_get:PeerInfo.platform)
  return platform_.GetNoArena();
}
inline void PeerInfo::set_platform(const ::std::string& value) {
  
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PeerInfo.platform)
}
#if LANG_CXX11
inline void PeerInfo::set_platform(::std::string&& value) {
  
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PeerInfo.platform)
}
#endif
inline void PeerInfo::set_platform(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PeerInfo.platform)
}
inline void PeerInfo::set_platform(const char* value, size_t size) {
  
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PeerInfo.platform)
}
inline ::std::string* PeerInfo::mutable_platform() {
  
  // @@protoc_insertion_point(field_mutable:PeerInfo.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerInfo::release_platform() {
  // @@protoc_insertion_point(field_release:PeerInfo.platform)
  
  return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerInfo::set_allocated_platform(::std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:PeerInfo.platform)
}

// string version = 4;
inline void PeerInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerInfo::version() const {
  // @@protoc_insertion_point(field_get:PeerInfo.version)
  return version_.GetNoArena();
}
inline void PeerInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PeerInfo.version)
}
#if LANG_CXX11
inline void PeerInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PeerInfo.version)
}
#endif
inline void PeerInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PeerInfo.version)
}
inline void PeerInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PeerInfo.version)
}
inline ::std::string* PeerInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:PeerInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerInfo::release_version() {
  // @@protoc_insertion_point(field_release:PeerInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerInfo::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:PeerInfo.version)
}

// bool privacy_mode = 5;
inline void PeerInfo::clear_privacy_mode() {
  privacy_mode_ = false;
}
inline bool PeerInfo::privacy_mode() const {
  // @@protoc_insertion_point(field_get:PeerInfo.privacy_mode)
  return privacy_mode_;
}
inline void PeerInfo::set_privacy_mode(bool value) {
  
  privacy_mode_ = value;
  // @@protoc_insertion_point(field_set:PeerInfo.privacy_mode)
}

// -------------------------------------------------------------------

// OptionMessage

// string feature = 1;
inline void OptionMessage::clear_feature() {
  feature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OptionMessage::feature() const {
  // @@protoc_insertion_point(field_get:OptionMessage.feature)
  return feature_.GetNoArena();
}
inline void OptionMessage::set_feature(const ::std::string& value) {
  
  feature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OptionMessage.feature)
}
#if LANG_CXX11
inline void OptionMessage::set_feature(::std::string&& value) {
  
  feature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:OptionMessage.feature)
}
#endif
inline void OptionMessage::set_feature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  feature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OptionMessage.feature)
}
inline void OptionMessage::set_feature(const char* value, size_t size) {
  
  feature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OptionMessage.feature)
}
inline ::std::string* OptionMessage::mutable_feature() {
  
  // @@protoc_insertion_point(field_mutable:OptionMessage.feature)
  return feature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OptionMessage::release_feature() {
  // @@protoc_insertion_point(field_release:OptionMessage.feature)
  
  return feature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OptionMessage::set_allocated_feature(::std::string* feature) {
  if (feature != nullptr) {
    
  } else {
    
  }
  feature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), feature);
  // @@protoc_insertion_point(field_set_allocated:OptionMessage.feature)
}

// bool enable = 2;
inline void OptionMessage::clear_enable() {
  enable_ = false;
}
inline bool OptionMessage::enable() const {
  // @@protoc_insertion_point(field_get:OptionMessage.enable)
  return enable_;
}
inline void OptionMessage::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:OptionMessage.enable)
}

// -------------------------------------------------------------------

// FileEntry

// .FileType type = 1;
inline void FileEntry::clear_type() {
  type_ = 0;
}
inline ::FileType FileEntry::type() const {
  // @@protoc_insertion_point(field_get:FileEntry.type)
  return static_cast< ::FileType >(type_);
}
inline void FileEntry::set_type(::FileType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:FileEntry.type)
}

// string name = 2;
inline void FileEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileEntry::name() const {
  // @@protoc_insertion_point(field_get:FileEntry.name)
  return name_.GetNoArena();
}
inline void FileEntry::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEntry.name)
}
#if LANG_CXX11
inline void FileEntry::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileEntry.name)
}
#endif
inline void FileEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEntry.name)
}
inline void FileEntry::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEntry.name)
}
inline ::std::string* FileEntry::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:FileEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileEntry::release_name() {
  // @@protoc_insertion_point(field_release:FileEntry.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEntry::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:FileEntry.name)
}

// bool hidden = 3;
inline void FileEntry::clear_hidden() {
  hidden_ = false;
}
inline bool FileEntry::hidden() const {
  // @@protoc_insertion_point(field_get:FileEntry.hidden)
  return hidden_;
}
inline void FileEntry::set_hidden(bool value) {
  
  hidden_ = value;
  // @@protoc_insertion_point(field_set:FileEntry.hidden)
}

// int64 size = 4;
inline void FileEntry::clear_size() {
  size_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 FileEntry::size() const {
  // @@protoc_insertion_point(field_get:FileEntry.size)
  return size_;
}
inline void FileEntry::set_size(::google::protobuf::int64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:FileEntry.size)
}

// int64 modified_time = 5;
inline void FileEntry::clear_modified_time() {
  modified_time_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 FileEntry::modified_time() const {
  // @@protoc_insertion_point(field_get:FileEntry.modified_time)
  return modified_time_;
}
inline void FileEntry::set_modified_time(::google::protobuf::int64 value) {
  
  modified_time_ = value;
  // @@protoc_insertion_point(field_set:FileEntry.modified_time)
}

// -------------------------------------------------------------------

// FileDirectory

// int32 id = 1;
inline void FileDirectory::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileDirectory::id() const {
  // @@protoc_insertion_point(field_get:FileDirectory.id)
  return id_;
}
inline void FileDirectory::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileDirectory.id)
}

// string path = 2;
inline void FileDirectory::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileDirectory::path() const {
  // @@protoc_insertion_point(field_get:FileDirectory.path)
  return path_.GetNoArena();
}
inline void FileDirectory::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileDirectory.path)
}
#if LANG_CXX11
inline void FileDirectory::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileDirectory.path)
}
#endif
inline void FileDirectory::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileDirectory.path)
}
inline void FileDirectory::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileDirectory.path)
}
inline ::std::string* FileDirectory::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileDirectory.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileDirectory::release_path() {
  // @@protoc_insertion_point(field_release:FileDirectory.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDirectory::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileDirectory.path)
}

// repeated .FileEntry entries = 3;
inline int FileDirectory::entries_size() const {
  return entries_.size();
}
inline void FileDirectory::clear_entries() {
  entries_.Clear();
}
inline ::FileEntry* FileDirectory::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:FileDirectory.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::FileEntry >*
FileDirectory::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:FileDirectory.entries)
  return &entries_;
}
inline const ::FileEntry& FileDirectory::entries(int index) const {
  // @@protoc_insertion_point(field_get:FileDirectory.entries)
  return entries_.Get(index);
}
inline ::FileEntry* FileDirectory::add_entries() {
  // @@protoc_insertion_point(field_add:FileDirectory.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileEntry >&
FileDirectory::entries() const {
  // @@protoc_insertion_point(field_list:FileDirectory.entries)
  return entries_;
}

// -------------------------------------------------------------------

// ActionResult

// int32 id = 1;
inline void ActionResult::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ActionResult::id() const {
  // @@protoc_insertion_point(field_get:ActionResult.id)
  return id_;
}
inline void ActionResult::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:ActionResult.id)
}

// string path = 2;
inline void ActionResult::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ActionResult::path() const {
  // @@protoc_insertion_point(field_get:ActionResult.path)
  return path_.GetNoArena();
}
inline void ActionResult::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ActionResult.path)
}
#if LANG_CXX11
inline void ActionResult::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ActionResult.path)
}
#endif
inline void ActionResult::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ActionResult.path)
}
inline void ActionResult::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ActionResult.path)
}
inline ::std::string* ActionResult::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:ActionResult.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionResult::release_path() {
  // @@protoc_insertion_point(field_release:ActionResult.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionResult::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ActionResult.path)
}

// bool result = 3;
inline void ActionResult::clear_result() {
  result_ = false;
}
inline bool ActionResult::result() const {
  // @@protoc_insertion_point(field_get:ActionResult.result)
  return result_;
}
inline void ActionResult::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:ActionResult.result)
}

// -------------------------------------------------------------------

// ReadDirFiles

// int32 id = 1;
inline void ReadDirFiles::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ReadDirFiles::id() const {
  // @@protoc_insertion_point(field_get:ReadDirFiles.id)
  return id_;
}
inline void ReadDirFiles::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:ReadDirFiles.id)
}

// string path = 2;
inline void ReadDirFiles::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadDirFiles::path() const {
  // @@protoc_insertion_point(field_get:ReadDirFiles.path)
  return path_.GetNoArena();
}
inline void ReadDirFiles::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ReadDirFiles.path)
}
#if LANG_CXX11
inline void ReadDirFiles::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ReadDirFiles.path)
}
#endif
inline void ReadDirFiles::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ReadDirFiles.path)
}
inline void ReadDirFiles::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ReadDirFiles.path)
}
inline ::std::string* ReadDirFiles::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:ReadDirFiles.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadDirFiles::release_path() {
  // @@protoc_insertion_point(field_release:ReadDirFiles.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadDirFiles::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ReadDirFiles.path)
}

// bool include_hidden = 3;
inline void ReadDirFiles::clear_include_hidden() {
  include_hidden_ = false;
}
inline bool ReadDirFiles::include_hidden() const {
  // @@protoc_insertion_point(field_get:ReadDirFiles.include_hidden)
  return include_hidden_;
}
inline void ReadDirFiles::set_include_hidden(bool value) {
  
  include_hidden_ = value;
  // @@protoc_insertion_point(field_set:ReadDirFiles.include_hidden)
}

// bool recursive = 4;
inline void ReadDirFiles::clear_recursive() {
  recursive_ = false;
}
inline bool ReadDirFiles::recursive() const {
  // @@protoc_insertion_point(field_get:ReadDirFiles.recursive)
  return recursive_;
}
inline void ReadDirFiles::set_recursive(bool value) {
  
  recursive_ = value;
  // @@protoc_insertion_point(field_set:ReadDirFiles.recursive)
}

// -------------------------------------------------------------------

// FileRemove

// int32 id = 1;
inline void FileRemove::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileRemove::id() const {
  // @@protoc_insertion_point(field_get:FileRemove.id)
  return id_;
}
inline void FileRemove::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileRemove.id)
}

// string path = 2;
inline void FileRemove::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileRemove::path() const {
  // @@protoc_insertion_point(field_get:FileRemove.path)
  return path_.GetNoArena();
}
inline void FileRemove::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileRemove.path)
}
#if LANG_CXX11
inline void FileRemove::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileRemove.path)
}
#endif
inline void FileRemove::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileRemove.path)
}
inline void FileRemove::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileRemove.path)
}
inline ::std::string* FileRemove::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileRemove.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileRemove::release_path() {
  // @@protoc_insertion_point(field_release:FileRemove.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileRemove::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileRemove.path)
}

// bool recursive = 3;
inline bool FileRemove::has_recursive() const {
  return union_case() == kRecursive;
}
inline void FileRemove::set_has_recursive() {
  _oneof_case_[0] = kRecursive;
}
inline void FileRemove::clear_recursive() {
  if (has_recursive()) {
    union_.recursive_ = false;
    clear_has_union();
  }
}
inline bool FileRemove::recursive() const {
  // @@protoc_insertion_point(field_get:FileRemove.recursive)
  if (has_recursive()) {
    return union_.recursive_;
  }
  return false;
}
inline void FileRemove::set_recursive(bool value) {
  if (!has_recursive()) {
    clear_union();
    set_has_recursive();
  }
  union_.recursive_ = value;
  // @@protoc_insertion_point(field_set:FileRemove.recursive)
}

// uint32 file_num = 4;
inline bool FileRemove::has_file_num() const {
  return union_case() == kFileNum;
}
inline void FileRemove::set_has_file_num() {
  _oneof_case_[0] = kFileNum;
}
inline void FileRemove::clear_file_num() {
  if (has_file_num()) {
    union_.file_num_ = 0u;
    clear_has_union();
  }
}
inline ::google::protobuf::uint32 FileRemove::file_num() const {
  // @@protoc_insertion_point(field_get:FileRemove.file_num)
  if (has_file_num()) {
    return union_.file_num_;
  }
  return 0u;
}
inline void FileRemove::set_file_num(::google::protobuf::uint32 value) {
  if (!has_file_num()) {
    clear_union();
    set_has_file_num();
  }
  union_.file_num_ = value;
  // @@protoc_insertion_point(field_set:FileRemove.file_num)
}

inline bool FileRemove::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void FileRemove::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline FileRemove::UnionCase FileRemove::union_case() const {
  return FileRemove::UnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileRename

// int32 id = 1;
inline void FileRename::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileRename::id() const {
  // @@protoc_insertion_point(field_get:FileRename.id)
  return id_;
}
inline void FileRename::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileRename.id)
}

// string path = 2;
inline void FileRename::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileRename::path() const {
  // @@protoc_insertion_point(field_get:FileRename.path)
  return path_.GetNoArena();
}
inline void FileRename::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileRename.path)
}
#if LANG_CXX11
inline void FileRename::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileRename.path)
}
#endif
inline void FileRename::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileRename.path)
}
inline void FileRename::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileRename.path)
}
inline ::std::string* FileRename::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileRename.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileRename::release_path() {
  // @@protoc_insertion_point(field_release:FileRename.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileRename::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileRename.path)
}

// -------------------------------------------------------------------

// FileCreate

// int32 id = 1;
inline void FileCreate::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileCreate::id() const {
  // @@protoc_insertion_point(field_get:FileCreate.id)
  return id_;
}
inline void FileCreate::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileCreate.id)
}

// string path = 2;
inline void FileCreate::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileCreate::path() const {
  // @@protoc_insertion_point(field_get:FileCreate.path)
  return path_.GetNoArena();
}
inline void FileCreate::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileCreate.path)
}
#if LANG_CXX11
inline void FileCreate::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileCreate.path)
}
#endif
inline void FileCreate::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileCreate.path)
}
inline void FileCreate::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileCreate.path)
}
inline ::std::string* FileCreate::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileCreate.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileCreate::release_path() {
  // @@protoc_insertion_point(field_release:FileCreate.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileCreate::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileCreate.path)
}

// bool is_dir = 3;
inline void FileCreate::clear_is_dir() {
  is_dir_ = false;
}
inline bool FileCreate::is_dir() const {
  // @@protoc_insertion_point(field_get:FileCreate.is_dir)
  return is_dir_;
}
inline void FileCreate::set_is_dir(bool value) {
  
  is_dir_ = value;
  // @@protoc_insertion_point(field_set:FileCreate.is_dir)
}

// -------------------------------------------------------------------

// FileAction

// .ReadDirFiles read_files = 1;
inline bool FileAction::has_read_files() const {
  return union_case() == kReadFiles;
}
inline void FileAction::set_has_read_files() {
  _oneof_case_[0] = kReadFiles;
}
inline void FileAction::clear_read_files() {
  if (has_read_files()) {
    delete union_.read_files_;
    clear_has_union();
  }
}
inline ::ReadDirFiles* FileAction::release_read_files() {
  // @@protoc_insertion_point(field_release:FileAction.read_files)
  if (has_read_files()) {
    clear_has_union();
      ::ReadDirFiles* temp = union_.read_files_;
    union_.read_files_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ReadDirFiles& FileAction::read_files() const {
  // @@protoc_insertion_point(field_get:FileAction.read_files)
  return has_read_files()
      ? *union_.read_files_
      : *reinterpret_cast< ::ReadDirFiles*>(&::_ReadDirFiles_default_instance_);
}
inline ::ReadDirFiles* FileAction::mutable_read_files() {
  if (!has_read_files()) {
    clear_union();
    set_has_read_files();
    union_.read_files_ = CreateMaybeMessage< ::ReadDirFiles >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.read_files)
  return union_.read_files_;
}

// .FileCreate create = 2;
inline bool FileAction::has_create() const {
  return union_case() == kCreate;
}
inline void FileAction::set_has_create() {
  _oneof_case_[0] = kCreate;
}
inline void FileAction::clear_create() {
  if (has_create()) {
    delete union_.create_;
    clear_has_union();
  }
}
inline ::FileCreate* FileAction::release_create() {
  // @@protoc_insertion_point(field_release:FileAction.create)
  if (has_create()) {
    clear_has_union();
      ::FileCreate* temp = union_.create_;
    union_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileCreate& FileAction::create() const {
  // @@protoc_insertion_point(field_get:FileAction.create)
  return has_create()
      ? *union_.create_
      : *reinterpret_cast< ::FileCreate*>(&::_FileCreate_default_instance_);
}
inline ::FileCreate* FileAction::mutable_create() {
  if (!has_create()) {
    clear_union();
    set_has_create();
    union_.create_ = CreateMaybeMessage< ::FileCreate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.create)
  return union_.create_;
}

// .FileRemove remove = 3;
inline bool FileAction::has_remove() const {
  return union_case() == kRemove;
}
inline void FileAction::set_has_remove() {
  _oneof_case_[0] = kRemove;
}
inline void FileAction::clear_remove() {
  if (has_remove()) {
    delete union_.remove_;
    clear_has_union();
  }
}
inline ::FileRemove* FileAction::release_remove() {
  // @@protoc_insertion_point(field_release:FileAction.remove)
  if (has_remove()) {
    clear_has_union();
      ::FileRemove* temp = union_.remove_;
    union_.remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileRemove& FileAction::remove() const {
  // @@protoc_insertion_point(field_get:FileAction.remove)
  return has_remove()
      ? *union_.remove_
      : *reinterpret_cast< ::FileRemove*>(&::_FileRemove_default_instance_);
}
inline ::FileRemove* FileAction::mutable_remove() {
  if (!has_remove()) {
    clear_union();
    set_has_remove();
    union_.remove_ = CreateMaybeMessage< ::FileRemove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.remove)
  return union_.remove_;
}

// .FileRename rename = 4;
inline bool FileAction::has_rename() const {
  return union_case() == kRename;
}
inline void FileAction::set_has_rename() {
  _oneof_case_[0] = kRename;
}
inline void FileAction::clear_rename() {
  if (has_rename()) {
    delete union_.rename_;
    clear_has_union();
  }
}
inline ::FileRename* FileAction::release_rename() {
  // @@protoc_insertion_point(field_release:FileAction.rename)
  if (has_rename()) {
    clear_has_union();
      ::FileRename* temp = union_.rename_;
    union_.rename_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileRename& FileAction::rename() const {
  // @@protoc_insertion_point(field_get:FileAction.rename)
  return has_rename()
      ? *union_.rename_
      : *reinterpret_cast< ::FileRename*>(&::_FileRename_default_instance_);
}
inline ::FileRename* FileAction::mutable_rename() {
  if (!has_rename()) {
    clear_union();
    set_has_rename();
    union_.rename_ = CreateMaybeMessage< ::FileRename >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileAction.rename)
  return union_.rename_;
}

inline bool FileAction::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void FileAction::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline FileAction::UnionCase FileAction::union_case() const {
  return FileAction::UnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileResponse

// .FileDirectory dir = 1;
inline bool FileResponse::has_dir() const {
  return union_case() == kDir;
}
inline void FileResponse::set_has_dir() {
  _oneof_case_[0] = kDir;
}
inline void FileResponse::clear_dir() {
  if (has_dir()) {
    delete union_.dir_;
    clear_has_union();
  }
}
inline ::FileDirectory* FileResponse::release_dir() {
  // @@protoc_insertion_point(field_release:FileResponse.dir)
  if (has_dir()) {
    clear_has_union();
      ::FileDirectory* temp = union_.dir_;
    union_.dir_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileDirectory& FileResponse::dir() const {
  // @@protoc_insertion_point(field_get:FileResponse.dir)
  return has_dir()
      ? *union_.dir_
      : *reinterpret_cast< ::FileDirectory*>(&::_FileDirectory_default_instance_);
}
inline ::FileDirectory* FileResponse::mutable_dir() {
  if (!has_dir()) {
    clear_union();
    set_has_dir();
    union_.dir_ = CreateMaybeMessage< ::FileDirectory >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileResponse.dir)
  return union_.dir_;
}

// .ActionResult result = 2;
inline bool FileResponse::has_result() const {
  return union_case() == kResult;
}
inline void FileResponse::set_has_result() {
  _oneof_case_[0] = kResult;
}
inline void FileResponse::clear_result() {
  if (has_result()) {
    delete union_.result_;
    clear_has_union();
  }
}
inline ::ActionResult* FileResponse::release_result() {
  // @@protoc_insertion_point(field_release:FileResponse.result)
  if (has_result()) {
    clear_has_union();
      ::ActionResult* temp = union_.result_;
    union_.result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionResult& FileResponse::result() const {
  // @@protoc_insertion_point(field_get:FileResponse.result)
  return has_result()
      ? *union_.result_
      : *reinterpret_cast< ::ActionResult*>(&::_ActionResult_default_instance_);
}
inline ::ActionResult* FileResponse::mutable_result() {
  if (!has_result()) {
    clear_union();
    set_has_result();
    union_.result_ = CreateMaybeMessage< ::ActionResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileResponse.result)
  return union_.result_;
}

inline bool FileResponse::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void FileResponse::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline FileResponse::UnionCase FileResponse::union_case() const {
  return FileResponse::UnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileTransResponse

// int32 id = 1;
inline void FileTransResponse::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileTransResponse::id() const {
  // @@protoc_insertion_point(field_get:FileTransResponse.id)
  return id_;
}
inline void FileTransResponse::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:FileTransResponse.id)
}

// string name = 2;
inline void FileTransResponse::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransResponse::name() const {
  // @@protoc_insertion_point(field_get:FileTransResponse.name)
  return name_.GetNoArena();
}
inline void FileTransResponse::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransResponse.name)
}
#if LANG_CXX11
inline void FileTransResponse::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransResponse.name)
}
#endif
inline void FileTransResponse::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransResponse.name)
}
inline void FileTransResponse::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransResponse.name)
}
inline ::std::string* FileTransResponse::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:FileTransResponse.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransResponse::release_name() {
  // @@protoc_insertion_point(field_release:FileTransResponse.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransResponse::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:FileTransResponse.name)
}

// .FileTransRe result = 3;
inline void FileTransResponse::clear_result() {
  result_ = 0;
}
inline ::FileTransRe FileTransResponse::result() const {
  // @@protoc_insertion_point(field_get:FileTransResponse.result)
  return static_cast< ::FileTransRe >(result_);
}
inline void FileTransResponse::set_result(::FileTransRe value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:FileTransResponse.result)
}

// -------------------------------------------------------------------

// FileTransJob

// int32 job_id = 1;
inline void FileTransJob::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransJob::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransJob.job_id)
  return job_id_;
}
inline void FileTransJob::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransJob.job_id)
}

// string path = 2;
inline void FileTransJob::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJob::path() const {
  // @@protoc_insertion_point(field_get:FileTransJob.path)
  return path_.GetNoArena();
}
inline void FileTransJob::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJob.path)
}
#if LANG_CXX11
inline void FileTransJob::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJob.path)
}
#endif
inline void FileTransJob::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJob.path)
}
inline void FileTransJob::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJob.path)
}
inline ::std::string* FileTransJob::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJob.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJob::release_path() {
  // @@protoc_insertion_point(field_release:FileTransJob.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJob::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileTransJob.path)
}

// bool include_hidden = 3;
inline void FileTransJob::clear_include_hidden() {
  include_hidden_ = false;
}
inline bool FileTransJob::include_hidden() const {
  // @@protoc_insertion_point(field_get:FileTransJob.include_hidden)
  return include_hidden_;
}
inline void FileTransJob::set_include_hidden(bool value) {
  
  include_hidden_ = value;
  // @@protoc_insertion_point(field_set:FileTransJob.include_hidden)
}

// bool recursive = 4;
inline void FileTransJob::clear_recursive() {
  recursive_ = false;
}
inline bool FileTransJob::recursive() const {
  // @@protoc_insertion_point(field_get:FileTransJob.recursive)
  return recursive_;
}
inline void FileTransJob::set_recursive(bool value) {
  
  recursive_ = value;
  // @@protoc_insertion_point(field_set:FileTransJob.recursive)
}

// bool push = 5;
inline void FileTransJob::clear_push() {
  push_ = false;
}
inline bool FileTransJob::push() const {
  // @@protoc_insertion_point(field_get:FileTransJob.push)
  return push_;
}
inline void FileTransJob::set_push(bool value) {
  
  push_ = value;
  // @@protoc_insertion_point(field_set:FileTransJob.push)
}

// string app_who = 6;
inline void FileTransJob::clear_app_who() {
  app_who_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJob::app_who() const {
  // @@protoc_insertion_point(field_get:FileTransJob.app_who)
  return app_who_.GetNoArena();
}
inline void FileTransJob::set_app_who(const ::std::string& value) {
  
  app_who_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJob.app_who)
}
#if LANG_CXX11
inline void FileTransJob::set_app_who(::std::string&& value) {
  
  app_who_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJob.app_who)
}
#endif
inline void FileTransJob::set_app_who(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  app_who_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJob.app_who)
}
inline void FileTransJob::set_app_who(const char* value, size_t size) {
  
  app_who_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJob.app_who)
}
inline ::std::string* FileTransJob::mutable_app_who() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJob.app_who)
  return app_who_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJob::release_app_who() {
  // @@protoc_insertion_point(field_release:FileTransJob.app_who)
  
  return app_who_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJob::set_allocated_app_who(::std::string* app_who) {
  if (app_who != nullptr) {
    
  } else {
    
  }
  app_who_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_who);
  // @@protoc_insertion_point(field_set_allocated:FileTransJob.app_who)
}

// -------------------------------------------------------------------

// FileTransCreate

// int32 job_id = 1;
inline void FileTransCreate::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransCreate::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransCreate.job_id)
  return job_id_;
}
inline void FileTransCreate::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransCreate.job_id)
}

// int32 file_id = 2;
inline void FileTransCreate::clear_file_id() {
  file_id_ = 0;
}
inline ::google::protobuf::int32 FileTransCreate::file_id() const {
  // @@protoc_insertion_point(field_get:FileTransCreate.file_id)
  return file_id_;
}
inline void FileTransCreate::set_file_id(::google::protobuf::int32 value) {
  
  file_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransCreate.file_id)
}

// string sub_dir = 3;
inline void FileTransCreate::clear_sub_dir() {
  sub_dir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransCreate::sub_dir() const {
  // @@protoc_insertion_point(field_get:FileTransCreate.sub_dir)
  return sub_dir_.GetNoArena();
}
inline void FileTransCreate::set_sub_dir(const ::std::string& value) {
  
  sub_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransCreate.sub_dir)
}
#if LANG_CXX11
inline void FileTransCreate::set_sub_dir(::std::string&& value) {
  
  sub_dir_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransCreate.sub_dir)
}
#endif
inline void FileTransCreate::set_sub_dir(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sub_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransCreate.sub_dir)
}
inline void FileTransCreate::set_sub_dir(const char* value, size_t size) {
  
  sub_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransCreate.sub_dir)
}
inline ::std::string* FileTransCreate::mutable_sub_dir() {
  
  // @@protoc_insertion_point(field_mutable:FileTransCreate.sub_dir)
  return sub_dir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransCreate::release_sub_dir() {
  // @@protoc_insertion_point(field_release:FileTransCreate.sub_dir)
  
  return sub_dir_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransCreate::set_allocated_sub_dir(::std::string* sub_dir) {
  if (sub_dir != nullptr) {
    
  } else {
    
  }
  sub_dir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sub_dir);
  // @@protoc_insertion_point(field_set_allocated:FileTransCreate.sub_dir)
}

// .FileEntry entry = 4;
inline bool FileTransCreate::has_entry() const {
  return this != internal_default_instance() && entry_ != nullptr;
}
inline void FileTransCreate::clear_entry() {
  if (GetArenaNoVirtual() == nullptr && entry_ != nullptr) {
    delete entry_;
  }
  entry_ = nullptr;
}
inline const ::FileEntry& FileTransCreate::entry() const {
  const ::FileEntry* p = entry_;
  // @@protoc_insertion_point(field_get:FileTransCreate.entry)
  return p != nullptr ? *p : *reinterpret_cast<const ::FileEntry*>(
      &::_FileEntry_default_instance_);
}
inline ::FileEntry* FileTransCreate::release_entry() {
  // @@protoc_insertion_point(field_release:FileTransCreate.entry)
  
  ::FileEntry* temp = entry_;
  entry_ = nullptr;
  return temp;
}
inline ::FileEntry* FileTransCreate::mutable_entry() {
  
  if (entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::FileEntry>(GetArenaNoVirtual());
    entry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:FileTransCreate.entry)
  return entry_;
}
inline void FileTransCreate::set_allocated_entry(::FileEntry* entry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete entry_;
  }
  if (entry) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    
  } else {
    
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:FileTransCreate.entry)
}

// -------------------------------------------------------------------

// FileTransBlock

// int32 job_id = 1;
inline void FileTransBlock::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransBlock::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.job_id)
  return job_id_;
}
inline void FileTransBlock::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransBlock.job_id)
}

// int32 file_id = 2;
inline void FileTransBlock::clear_file_id() {
  file_id_ = 0;
}
inline ::google::protobuf::int32 FileTransBlock::file_id() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.file_id)
  return file_id_;
}
inline void FileTransBlock::set_file_id(::google::protobuf::int32 value) {
  
  file_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransBlock.file_id)
}

// string filename = 3;
inline void FileTransBlock::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransBlock::filename() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.filename)
  return filename_.GetNoArena();
}
inline void FileTransBlock::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransBlock.filename)
}
#if LANG_CXX11
inline void FileTransBlock::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransBlock.filename)
}
#endif
inline void FileTransBlock::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransBlock.filename)
}
inline void FileTransBlock::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransBlock.filename)
}
inline ::std::string* FileTransBlock::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:FileTransBlock.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransBlock::release_filename() {
  // @@protoc_insertion_point(field_release:FileTransBlock.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransBlock::set_allocated_filename(::std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:FileTransBlock.filename)
}

// uint32 blk_id = 4;
inline void FileTransBlock::clear_blk_id() {
  blk_id_ = 0u;
}
inline ::google::protobuf::uint32 FileTransBlock::blk_id() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.blk_id)
  return blk_id_;
}
inline void FileTransBlock::set_blk_id(::google::protobuf::uint32 value) {
  
  blk_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransBlock.blk_id)
}

// bytes data = 5;
inline void FileTransBlock::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransBlock::data() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.data)
  return data_.GetNoArena();
}
inline void FileTransBlock::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransBlock.data)
}
#if LANG_CXX11
inline void FileTransBlock::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransBlock.data)
}
#endif
inline void FileTransBlock::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransBlock.data)
}
inline void FileTransBlock::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransBlock.data)
}
inline ::std::string* FileTransBlock::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:FileTransBlock.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransBlock::release_data() {
  // @@protoc_insertion_point(field_release:FileTransBlock.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransBlock::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:FileTransBlock.data)
}

// bool compressed = 6;
inline void FileTransBlock::clear_compressed() {
  compressed_ = false;
}
inline bool FileTransBlock::compressed() const {
  // @@protoc_insertion_point(field_get:FileTransBlock.compressed)
  return compressed_;
}
inline void FileTransBlock::set_compressed(bool value) {
  
  compressed_ = value;
  // @@protoc_insertion_point(field_set:FileTransBlock.compressed)
}

// -------------------------------------------------------------------

// FileTransJobCancel

// int32 job_id = 1;
inline void FileTransJobCancel::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransJobCancel::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransJobCancel.job_id)
  return job_id_;
}
inline void FileTransJobCancel::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransJobCancel.job_id)
}

// string path = 2;
inline void FileTransJobCancel::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJobCancel::path() const {
  // @@protoc_insertion_point(field_get:FileTransJobCancel.path)
  return path_.GetNoArena();
}
inline void FileTransJobCancel::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJobCancel.path)
}
#if LANG_CXX11
inline void FileTransJobCancel::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJobCancel.path)
}
#endif
inline void FileTransJobCancel::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJobCancel.path)
}
inline void FileTransJobCancel::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJobCancel.path)
}
inline ::std::string* FileTransJobCancel::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJobCancel.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJobCancel::release_path() {
  // @@protoc_insertion_point(field_release:FileTransJobCancel.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJobCancel::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileTransJobCancel.path)
}

// -------------------------------------------------------------------

// FileTransJobReport

// int32 job_id = 1;
inline void FileTransJobReport::clear_job_id() {
  job_id_ = 0;
}
inline ::google::protobuf::int32 FileTransJobReport::job_id() const {
  // @@protoc_insertion_point(field_get:FileTransJobReport.job_id)
  return job_id_;
}
inline void FileTransJobReport::set_job_id(::google::protobuf::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:FileTransJobReport.job_id)
}

// string path = 2;
inline void FileTransJobReport::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJobReport::path() const {
  // @@protoc_insertion_point(field_get:FileTransJobReport.path)
  return path_.GetNoArena();
}
inline void FileTransJobReport::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJobReport.path)
}
#if LANG_CXX11
inline void FileTransJobReport::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJobReport.path)
}
#endif
inline void FileTransJobReport::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJobReport.path)
}
inline void FileTransJobReport::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJobReport.path)
}
inline ::std::string* FileTransJobReport::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJobReport.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJobReport::release_path() {
  // @@protoc_insertion_point(field_release:FileTransJobReport.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJobReport::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FileTransJobReport.path)
}

// string error = 3;
inline void FileTransJobReport::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransJobReport::error() const {
  // @@protoc_insertion_point(field_get:FileTransJobReport.error)
  return error_.GetNoArena();
}
inline void FileTransJobReport::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileTransJobReport.error)
}
#if LANG_CXX11
inline void FileTransJobReport::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FileTransJobReport.error)
}
#endif
inline void FileTransJobReport::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileTransJobReport.error)
}
inline void FileTransJobReport::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileTransJobReport.error)
}
inline ::std::string* FileTransJobReport::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:FileTransJobReport.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransJobReport::release_error() {
  // @@protoc_insertion_point(field_release:FileTransJobReport.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransJobReport::set_allocated_error(::std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:FileTransJobReport.error)
}

// .FileTransRe result = 4;
inline void FileTransJobReport::clear_result() {
  result_ = 0;
}
inline ::FileTransRe FileTransJobReport::result() const {
  // @@protoc_insertion_point(field_get:FileTransJobReport.result)
  return static_cast< ::FileTransRe >(result_);
}
inline void FileTransJobReport::set_result(::FileTransRe value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:FileTransJobReport.result)
}

// -------------------------------------------------------------------

// FileTransUpdate

// .FileTransJobCancel cancel = 1;
inline bool FileTransUpdate::has_cancel() const {
  return union_case() == kCancel;
}
inline void FileTransUpdate::set_has_cancel() {
  _oneof_case_[0] = kCancel;
}
inline void FileTransUpdate::clear_cancel() {
  if (has_cancel()) {
    delete union_.cancel_;
    clear_has_union();
  }
}
inline ::FileTransJobCancel* FileTransUpdate::release_cancel() {
  // @@protoc_insertion_point(field_release:FileTransUpdate.cancel)
  if (has_cancel()) {
    clear_has_union();
      ::FileTransJobCancel* temp = union_.cancel_;
    union_.cancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransJobCancel& FileTransUpdate::cancel() const {
  // @@protoc_insertion_point(field_get:FileTransUpdate.cancel)
  return has_cancel()
      ? *union_.cancel_
      : *reinterpret_cast< ::FileTransJobCancel*>(&::_FileTransJobCancel_default_instance_);
}
inline ::FileTransJobCancel* FileTransUpdate::mutable_cancel() {
  if (!has_cancel()) {
    clear_union();
    set_has_cancel();
    union_.cancel_ = CreateMaybeMessage< ::FileTransJobCancel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileTransUpdate.cancel)
  return union_.cancel_;
}

// .FileTransJobReport report = 2;
inline bool FileTransUpdate::has_report() const {
  return union_case() == kReport;
}
inline void FileTransUpdate::set_has_report() {
  _oneof_case_[0] = kReport;
}
inline void FileTransUpdate::clear_report() {
  if (has_report()) {
    delete union_.report_;
    clear_has_union();
  }
}
inline ::FileTransJobReport* FileTransUpdate::release_report() {
  // @@protoc_insertion_point(field_release:FileTransUpdate.report)
  if (has_report()) {
    clear_has_union();
      ::FileTransJobReport* temp = union_.report_;
    union_.report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransJobReport& FileTransUpdate::report() const {
  // @@protoc_insertion_point(field_get:FileTransUpdate.report)
  return has_report()
      ? *union_.report_
      : *reinterpret_cast< ::FileTransJobReport*>(&::_FileTransJobReport_default_instance_);
}
inline ::FileTransJobReport* FileTransUpdate::mutable_report() {
  if (!has_report()) {
    clear_union();
    set_has_report();
    union_.report_ = CreateMaybeMessage< ::FileTransJobReport >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:FileTransUpdate.report)
  return union_.report_;
}

inline bool FileTransUpdate::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void FileTransUpdate::clear_has_union() {
  _oneof_case_[0] = UNION_NOT_SET;
}
inline FileTransUpdate::UnionCase FileTransUpdate::union_case() const {
  return FileTransUpdate::UnionCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileType>() {
  return ::FileType_descriptor();
}
template <> struct is_proto_enum< ::FileTransRe> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileTransRe>() {
  return ::FileTransRe_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_message_2eproto
